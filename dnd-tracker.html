<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DnD Combat Tracker</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .form-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, button {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: bold;
        }

        button:hover {
            background: #2980b9;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-warning {
            background: #f39c12;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-purple {
            background: #9b59b6;
        }

        .btn-purple:hover {
            background: #8e44ad;
        }

        .character-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 15px;
        }

        .character-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 2px solid #ecf0f1;
        }

        .character-card.active {
            border-color: #f39c12;
            background: #fff8e1;
        }

        .character-card.played {
            opacity: 0.6;
            background: #f5f5f5;
        }

        .character-card.dragging {
            opacity: 0.5;
            cursor: move;
        }

        .character-card.drag-over {
            border-top: 3px solid #3498db;
        }

        .character-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .character-name {
            font-weight: bold;
            font-size: 1.1em;
            color: #2c3e50;
            cursor: pointer;
        }

        .character-name:hover {
            color: #3498db;
        }

        .character-type {
            background: #ecf0f1;
            padding: 3px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            color: #7f8c8d;
        }

        .group-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .character-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .stat-group {
            text-align: center;
            flex: 1;
        }

        .stat-label {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.2em;
            color: #2c3e50;
        }

        .init-bonus {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-left: 5px;
        }

        .controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }

        .control-btn {
            padding: 5px 10px;
            font-size: 0.8em;
        }

        .file-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .hidden {
            display: none;
        }

        .combat-controls {
            text-align: center;
            margin: 20px 0;
        }

        .initiative-order {
            font-size: 1.1em;
            margin-bottom: 20px;
            padding: 15px;
            background: #e8f4fd;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }

        .turn-info {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        #fileInput {
            display: none;
        }

        .hp-bar {
            width: 100%;
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .hp-fill {
            height: 100%;
            background: #27ae60;
            transition: width 0.3s, background-color 0.3s;
        }

        .hp-fill.low {
            background: #e74c3c;
        }

        .hp-fill.medium {
            background: #f39c12;
        }

        .effects {
            margin: 10px 0;
            min-height: 25px;
        }

        .effect-tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            margin: 2px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .effect-tag.buff {
            background: #27ae60;
            color: white;
        }

        .effect-tag.debuff {
            background: #e74c3c;
            color: white;
        }

        .effect-tag.neutral {
            background: #3498db;
            color: white;
        }

        .effect-tag:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .effect-controls {
            margin: 15px 0;
        }

        .effect-select {
            width: 150px;
            font-size: 0.9em;
            padding: 5px;
            margin-right: 10px;
        }

        .effect-input {
            width: 120px;
            font-size: 0.8em;
            padding: 5px;
            margin-right: 10px;
        }

        .effect-description {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.85em;
            line-height: 1.4;
            border-left: 3px solid #3498db;
        }

        .effect-list-container {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }

        .effect-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
            background: white;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .effect-item:hover {
            background: #f8f9fa;
        }

        .custom-hp-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            margin-top: 5px;
        }

        .custom-input {
            width: 60px;
            font-size: 0.8em;
            padding: 3px 6px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .power-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            margin-top: 5px;
        }

        .power-input {
            width: 40px;
            font-size: 0.8em;
            padding: 3px;
            text-align: center;
        }

        /* Monster database styles */
        .monster-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .monster-card:hover {
            border-color: #3498db;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .monster-info {
            flex: 1;
        }

        .monster-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            cursor: help;
            position: relative;
        }

        .monster-stats-quick {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .monster-actions {
            display: flex;
            gap: 5px;
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            display: none;
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            max-width: 400px;
            font-size: 0.85em;
            line-height: 1.5;
        }

        .tooltip.show {
            display: block;
        }

        .tooltip h4 {
            margin: 0 0 10px 0;
            color: #3498db;
        }

        .tooltip-section {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .tooltip-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        /* Statblock panel (collapsible) */
        .statblock-panel {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 3px solid #3498db;
            display: none;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .statblock-panel.show {
            display: block;
        }

        .statblock-panel h5 {
            margin: 10px 0 5px 0;
            color: #3498db;
        }

        .statblock-toggle {
            cursor: pointer;
            color: #3498db;
            font-size: 0.9em;
            margin-top: 5px;
            display: inline-block;
        }

        .statblock-toggle:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h1>🐉 DnD Combat Tracker</h1>
            <div style="text-align: right;">
                <div id="viewMode" style="font-size: 0.9em; color: #7f8c8d; margin-bottom: 5px;"></div>
                <div id="connectionStatus" style="font-size: 0.9em;">🔴 Disconnected</div>
            </div>
        </div>

        <div class="section" id="dataManagementSection">
            <h2>📁 Správa dat</h2>
            <div class="file-controls">
                <button onclick="saveData()">💾 Uložit data</button>
                <button onclick="saveCombatState()" class="btn-warning" id="saveCombatBtn" style="display:none;">⚔️ Uložit stav boje</button>
                <button onclick="document.getElementById('fileInput').click()">📂 Načíst data (kumulativně)</button>
                <input type="file" id="fileInput" accept=".json" onchange="loadData(event)">
                <button onclick="document.getElementById('combatFileInput').click()" class="btn-success">⚔️ Načíst stav boje</button>
                <input type="file" id="combatFileInput" accept=".json" onchange="loadCombatState(event)" style="display:none;">
                <button onclick="openMonsterDatabase()" class="btn-purple">📚 Databáze monster</button>
                <button onclick="clearAll()" class="btn-danger">🗑️ Vymazat vše</button>
            </div>
        </div>

        <div class="section" id="addCharacterSection">
            <h2>➕ Přidat postavu/monstrum</h2>
            <div class="form-group">
                <input type="text" id="name" placeholder="Jméno" required>
                <select id="type">
                    <option value="player">Hráč</option>
                    <option value="monster">Monstrum</option>
                </select>
                <input type="number" id="maxHp" placeholder="Max HP" required>
                <input type="number" id="currentHp" placeholder="Aktuální HP">
                <input type="number" id="ac" placeholder="AC (Armor Class)">
                <input type="number" id="initBonus" placeholder="Bonus na iniciativu">
                <input type="number" id="maxPower" placeholder="Max Moc">
                <input type="number" id="currentPower" placeholder="Aktuální Moc">
                <button onclick="addCharacter()">Přidat</button>
            </div>
        </div>

        <div class="section">
            <h2>⚔️ Boj</h2>
            <div class="combat-controls">
                <button onclick="startCombat()" class="btn-success" id="startBtn">🎲 Zahájit boj</button>
                <button onclick="previousTurn()" class="btn-warning hidden" id="prevBtn">⬅️ Předchozí tah</button>
                <button onclick="nextTurn()" class="btn-warning hidden" id="nextBtn">➡️ Další tah</button>
                <button onclick="endCombat()" class="btn-danger hidden" id="endBtn">🏁 Ukončit boj</button>
                <button onclick="closeCombat()" class="btn-purple hidden" id="closeBtn">🔒 Uzavřít boj</button>
            </div>
            <div id="initiativeOrder" class="initiative-order hidden"></div>
        </div>

        <div class="section">
            <h2>👥 Postavy a monstra</h2>
            <div id="characterList" class="character-list"></div>
        </div>
    </div>

    <!-- Modal pro databázi monster -->
    <div id="monsterDatabaseModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="closeMonsterDatabase()">&times;</span>
            <h3>📚 Databáze monster</h3>

            <div class="file-controls" style="margin-bottom: 15px;">
                <button onclick="openAddMonsterModal()" class="btn-success">➕ Přidat monstrum</button>
                <button onclick="exportMonsterDatabase()" class="btn-warning">💾 Exportovat databázi</button>
                <button onclick="document.getElementById('monsterDbFileInput').click()">📂 Importovat databázi</button>
                <input type="file" id="monsterDbFileInput" accept=".json" onchange="importMonsterDatabase(event)" style="display:none;">
            </div>

            <div id="monsterList" style="max-height: 500px; overflow-y: auto;"></div>
        </div>
    </div>

    <!-- Modal pro přidání/import monstra -->
    <div id="addMonsterModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="close" onclick="closeAddMonsterModal()">&times;</span>
            <h3>➕ Přidat monstrum do databáze</h3>

            <div style="margin: 15px 0;">
                <h4>Import z Notion linku:</h4>
                <input type="text" id="notionLinkInput" placeholder="https://www.notion.so/..." style="width: 100%; padding: 10px; margin-bottom: 10px;">
                <button onclick="importFromNotion()" class="btn-success">Načíst z Notion</button>
            </div>

            <div style="margin: 15px 0;">
                <h4>Nebo vložte statblock (Ctrl+V):</h4>
                <textarea id="statblockInput" placeholder="Vložte celý statblock..." style="width: 100%; height: 200px; padding: 10px; font-family: monospace; font-size: 0.9em;"></textarea>
                <button onclick="parseStatblock()" class="btn-success">Parsovat statblock</button>
            </div>

            <div id="monsterPreview" style="display: none; margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                <h4>Náhled:</h4>
                <div id="monsterPreviewContent"></div>
                <button onclick="saveMonsterToDatabase()" class="btn-success" style="margin-top: 10px;">💾 Uložit do databáze</button>
            </div>
        </div>
    </div>

    <!-- Modal pro efekty -->
    <div id="effectModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEffectModal()">&times;</span>
            <h3>🎭 Efekty pro <span id="effectCharacterName"></span></h3>
            <div id="effectList"></div>
            <div class="effect-controls">
                <h4>Přidat efekt:</h4>
                <div style="margin: 10px 0;">
                    <select id="effectSelect" class="effect-select">
                        <option value="">-- Vyberte efekt --</option>
                        <optgroup label="🔴 Debuffs">
                            <option value="Blinded">Blinded (Oslepený)</option>
                            <option value="Charmed">Charmed (Okouzlený)</option>
                            <option value="Deafened">Deafened (Ohlušený)</option>
                            <option value="Exhaustion">Exhaustion (Vyčerpání) - s levely 1-6</option>
                            <option value="Frightened">Frightened (Vystrašený)</option>
                            <option value="Grappled">Grappled (Uchvácený)</option>
                            <option value="Incapacitated">Incapacitated (Neschopný)</option>
                            <option value="Paralyzed">Paralyzed (Paralyzovaný)</option>
                            <option value="Petrified">Petrified (Zkamenělý)</option>
                            <option value="Poisoned">Poisoned (Otrávený)</option>
                            <option value="Prone">Prone (Ležící)</option>
                            <option value="Restrained">Restrained (Spoutaný)</option>
                            <option value="Stunned">Stunned (Omráčený)</option>
                            <option value="Unconscious">Unconscious (Bezvědomý)</option>
                        </optgroup>
                        <optgroup label="🟢 Buffs">
                            <option value="Blessed">Blessed (Požehnaný)</option>
                            <option value="Hasted">Hasted (Zrychlený)</option>
                            <option value="Inspired">Inspired (Inspirovaný)</option>
                            <option value="Protected">Protected (Chráněný)</option>
                            <option value="Enlarged">Enlarged (Zvětšený)</option>
                            <option value="Flying">Flying (Létající)</option>
                            <option value="Invisible">Invisible (Neviditelný)</option>
                            <option value="Resistance">Resistance (Odolnost)</option>
                            <option value="Advantage">Advantage (Výhoda)</option>
                            <option value="Raging">Raging (Běsnící)</option>
                            <option value="Dodging">Dodging (Vyhýbající se)</option>
                        </optgroup>
                        <optgroup label="🔵 Neutrální">
                            <option value="Concentrating">Concentrating (Soustředění)</option>
                            <option value="Marked">Marked (Označený)</option>
                        </optgroup>
                    </select>
                    <button onclick="addEffect()" class="btn-success">Přidat vybraný</button>
                </div>
                <div style="margin: 10px 0;">
                    <input type="text" id="newEffect" class="effect-input" placeholder="Vlastní efekt">
                    <button onclick="addEffect()" class="btn-success">Přidat vlastní</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal pro editaci monstra -->
    <div id="editMonsterModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEditMonsterModal()">&times;</span>
            <h3>✏️ Editovat monstrum</h3>

            <div style="margin: 20px 0;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;"><strong>Jméno:</strong></label>
                    <input type="text" id="editMonsterName" style="width: 100%; padding: 8px;">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>AC:</strong></label>
                        <input type="number" id="editMonsterAC" style="width: 100%; padding: 8px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>HP:</strong></label>
                        <input type="number" id="editMonsterHP" style="width: 100%; padding: 8px;">
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;"><strong>Speed:</strong></label>
                    <input type="text" id="editMonsterSpeed" style="width: 100%; padding: 8px;" placeholder="30 ft.">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>Type:</strong></label>
                        <input type="text" id="editMonsterType" style="width: 100%; padding: 8px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>Size:</strong></label>
                        <input type="text" id="editMonsterSize" style="width: 100%; padding: 8px;">
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #3498db;">⚡ Power Systém</h4>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;"><strong>Název Power:</strong></label>
                        <input type="text" id="editMonsterPowerName" style="width: 100%; padding: 8px;" placeholder="Power (nebo Grit, Fortitude, atd.)">
                        <small style="color: #7f8c8d; display: block; margin-top: 3px;">Vlastní název pro power resource tohoto monstra</small>
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>Maximální Power:</strong></label>
                        <input type="number" id="editMonsterMaxPower" style="width: 100%; padding: 8px;" placeholder="0">
                        <small style="color: #7f8c8d; display: block; margin-top: 3px;">Nechte 0 pokud monstrum nepoužívá power systém</small>
                    </div>
                </div>

                <button onclick="saveEditedMonster()" class="btn-success" style="width: 100%; padding: 12px; font-size: 1.1em;">💾 Uložit změny</button>
            </div>
        </div>
    </div>

    <script>
        // ===== MODE DETECTION & WEBSOCKET SETUP =====
        const urlParams = new URLSearchParams(window.location.search);
        const viewMode = urlParams.get('mode') || 'dm'; // 'dm' or 'player'
        const isDM = viewMode === 'dm';
        const isPlayer = viewMode === 'player';

        // Update title based on mode
        document.title = isDM ? 'DnD Tracker - DM' : 'DnD Tracker - Player View';

        // WebSocket connection
        let socket = null;
        let isConnected = false;
        let isSyncing = false; // Prevent sync loop

        function initializeWebSocket() {
            socket = io();

            socket.on('connect', () => {
                console.log('Connected to server');
                isConnected = true;
                updateConnectionStatus(true);
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                isConnected = false;
                updateConnectionStatus(false);
            });

            // Receive full state sync from server
            socket.on('state-sync', (serverState) => {
                isSyncing = true; // Set flag to prevent re-sync
                characters = serverState.characters || [];
                combatState = serverState.combatState || combatState;
                monsterDatabase = serverState.monsterDatabase || [];

                renderCharacters();
                renderMonsterList();
                updateInitiativeDisplay();
                isSyncing = false; // Clear flag
            });

            // Receive individual character updates
            socket.on('character-updated', (characterData) => {
                isSyncing = true;
                const index = characters.findIndex(c => c.id === characterData.id);
                if (index !== -1) {
                    characters[index] = characterData;
                    renderCharacters();
                }
                isSyncing = false;
            });

            // Receive combat state updates
            socket.on('combat-updated', (combatData) => {
                isSyncing = true;
                combatState = combatData;
                updateInitiativeDisplay();
                renderCharacters();
                isSyncing = false;
            });
        }

        // Send state updates to server
        function syncToServer() {
            if (isSyncing) return; // Don't sync if we're receiving updates
            if (socket && isConnected) {
                socket.emit('update-state', {
                    characters,
                    combatState,
                    monsterDatabase
                });
            }
        }

        function updateConnectionStatus(connected) {
            // Show connection status indicator
            const indicator = document.getElementById('connectionStatus');
            if (indicator) {
                indicator.textContent = connected ? '🟢 Connected' : '🔴 Disconnected';
                indicator.style.color = connected ? '#27ae60' : '#e74c3c';
            }
        }

        let characters = [];
        let combatState = {
            active: false,
            currentTurn: 0,
            round: 1,
            playedThisRound: []
        };
        let currentEffectCharacterId = null;
        let autoSaveInterval = null;
        let historyStack = [];
        const MAX_HISTORY = 20;
        let draggedCharacterIndex = null;
        let monsterDatabase = [];
        let currentMonsterForStatblock = null;
        let currentEditingMonsterId = null;

        // ===== MONSTER DATABASE FUNCTIONS =====

        // LocalStorage pro databázi monster
        function saveMonsterDatabaseToStorage() {
            try {
                localStorage.setItem('dnd-monster-database', JSON.stringify(monsterDatabase));
            } catch (error) {
                console.error('Error saving monster database:', error);
            }
        }

        function loadMonsterDatabaseFromStorage() {
            try {
                const saved = localStorage.getItem('dnd-monster-database');
                if (saved) {
                    monsterDatabase = JSON.parse(saved);
                }
            } catch (error) {
                console.error('Error loading monster database:', error);
            }
        }

        // Modal funkce
        function openMonsterDatabase() {
            document.getElementById('monsterDatabaseModal').style.display = 'block';
            renderMonsterList();
        }

        function closeMonsterDatabase() {
            document.getElementById('monsterDatabaseModal').style.display = 'none';
        }

        function openAddMonsterModal() {
            document.getElementById('addMonsterModal').style.display = 'block';
            document.getElementById('statblockInput').value = '';
            document.getElementById('notionLinkInput').value = '';
            document.getElementById('monsterPreview').style.display = 'none';
        }

        function closeAddMonsterModal() {
            document.getElementById('addMonsterModal').style.display = 'none';
            currentMonsterForStatblock = null;
        }

        // Parser pro statblock
        function parseStatblock() {
            const input = document.getElementById('statblockInput').value;
            if (!input.trim()) {
                alert('Vložte prosím statblock!');
                return;
            }

            const monster = parseStatblockText(input);
            if (monster) {
                currentMonsterForStatblock = monster;
                showMonsterPreview(monster);
            } else {
                alert('Nepodařilo se parsovat statblock. Zkontrolujte formát.');
            }
        }

        function parseStatblockText(text) {
            try {
                const monster = {
                    name: '',
                    ac: 10,
                    hp: 10,
                    speed: '30 ft.',
                    initBonus: 0,
                    stats: { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
                    cr: '0',
                    type: 'unknown',
                    size: 'medium',
                    savingThrows: '',
                    resistances: '',
                    immunities: '',
                    proficiency: '',
                    rawStatblock: text,
                    traits: [],
                    actions: []
                };

                // Parse název (první řádek nebo z **Armor Class:**)
                const firstLine = text.split('\n')[0].trim();
                if (firstLine && !firstLine.includes(':')) {
                    monster.name = firstLine.replace(/^#+ /, '');
                }

                // Parse AC
                const acMatch = text.match(/\*\*Armor Class:\*\*\s*(\d+)/i);
                if (acMatch) monster.ac = parseInt(acMatch[1]);

                // Parse HP
                const hpMatch = text.match(/\*\*Hit Points:\*\*\s*(\d+)/i);
                if (hpMatch) monster.hp = parseInt(hpMatch[1]);

                // Parse Speed
                const speedMatch = text.match(/\*\*Speed:\*\*\s*([^\n]+)/i);
                if (speedMatch) monster.speed = speedMatch[1].trim();

                // Parse Stats z tabulky
                const statsMatch = text.match(/\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|/);
                if (statsMatch) {
                    monster.stats.str = parseInt(statsMatch[1]);
                    monster.stats.dex = parseInt(statsMatch[2]);
                    monster.stats.con = parseInt(statsMatch[3]);
                    monster.stats.int = parseInt(statsMatch[4]);
                    monster.stats.wis = parseInt(statsMatch[5]);
                    monster.stats.cha = parseInt(statsMatch[6]);

                    // Vypočítej initiative bonus z Dexterity
                    monster.initBonus = Math.floor((monster.stats.dex - 10) / 2);
                }

                // Parse Saving Throws
                const savingThrowsMatch = text.match(/\*\*Saving Throws:\*\*\s*([^\n]+)/i);
                if (savingThrowsMatch) {
                    monster.savingThrows = savingThrowsMatch[1].trim().replace(/,\s*$/, ''); // Odstraň trailing comma
                }

                // Parse Damage Resistances
                const resistancesMatch = text.match(/\*\*Damage Resistances:\*\*\s*([^\n]+)/i);
                if (resistancesMatch) {
                    monster.resistances = resistancesMatch[1].trim();
                }

                // Parse Immunities
                const immunitiesMatch = text.match(/\*\*Immunities:\*\*\s*([^\n]+)/i);
                if (immunitiesMatch) {
                    // Odstraň Notion linky jako [Frightened](url)
                    monster.immunities = immunitiesMatch[1].trim().replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
                }

                // Parse Proficiency
                const proficiencyMatch = text.match(/\*\*Proficiency:\*\*\s*([+-]?\d+)/i);
                if (proficiencyMatch) {
                    monster.proficiency = proficiencyMatch[1];
                }

                // Parse Challenge points místo CR
                const challengeMatch = text.match(/\*\*Challenge\*\*\s*[\d\/]+\s*\((\d+)\s*points?\)/i);
                if (challengeMatch) {
                    monster.cr = challengeMatch[1] + ' point' + (challengeMatch[1] === '1' ? '' : 's');
                } else {
                    // Fallback na původní CR, pokud nejsou body
                    const crMatch = text.match(/\*\*Challenge\*\*\s*([\d\/]+)/i);
                    if (crMatch) monster.cr = crMatch[1];
                }

                // Parse Type
                const typeMatch = text.match(/\*\*Type:\*\*\s*(\w+)/i);
                if (typeMatch) monster.type = typeMatch[1].toLowerCase();

                // Parse Size
                const sizeMatch = text.match(/\*\*Size:\*\*\s*(\w+)/i);
                if (sizeMatch) monster.size = sizeMatch[1].toLowerCase();

                // Parse Traits (mezi # Defense Traits a # Actions) - zachovej seznamy a formátování
                const traitsSection = text.match(/# (?:Defense Traits|Regular Traits)([\s\S]*?)(?=# Actions|$)/i);
                if (traitsSection) {
                    // Rozděl podle patternu, kde trait začíná **Název** na začátku řádku
                    const traitBlocks = traitsSection[1].split(/(?=^\*\*[A-Z])/m).filter(t => t.trim());
                    monster.traits = traitBlocks.map(t => t.trim());
                }

                // Parse Actions - zachovej seznamy a formátování
                const actionsSection = text.match(/# Actions([\s\S]*?)(?=---|$)/i);
                if (actionsSection) {
                    // Rozděl podle patternu, kde action začíná **Název** na začátku řádku
                    const actionBlocks = actionsSection[1].split(/(?=^\*\*[A-Z])/m).filter(a => a.trim());
                    monster.actions = actionBlocks.map(a => a.trim());
                }

                // Pokud nemáme jméno, zkus najít první nadpis
                if (!monster.name) {
                    const nameMatch = text.match(/^#+ (.+)$/m);
                    if (nameMatch) monster.name = nameMatch[1].trim();
                }

                return monster;
            } catch (error) {
                console.error('Parse error:', error);
                return null;
            }
        }

        function showMonsterPreview(monster) {
            const preview = document.getElementById('monsterPreviewContent');

            // Formátuj staty s bonusy
            const statStr = (stat) => {
                const bonus = Math.floor((stat - 10) / 2);
                return `${stat} (${bonus >= 0 ? '+' : ''}${bonus})`;
            };

            preview.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <p><strong>Jméno:</strong> ${monster.name || 'Neznámé'}</p>
                    <p><strong>AC:</strong> ${monster.ac} | <strong>HP:</strong> ${monster.hp} | <strong>Speed:</strong> ${monster.speed}</p>
                    <p><strong>Type:</strong> ${monster.type} | <strong>Size:</strong> ${monster.size} | <strong>Challenge:</strong> ${monster.cr}</p>
                </div>

                <div style="margin-bottom: 15px; font-size: 0.9em;">
                    <table style="width: 100%; border-collapse: collapse; text-align: center;">
                        <tr style="background: #ecf0f1;">
                            <th style="padding: 5px;">STR</th>
                            <th style="padding: 5px;">DEX</th>
                            <th style="padding: 5px;">CON</th>
                            <th style="padding: 5px;">INT</th>
                            <th style="padding: 5px;">WIS</th>
                            <th style="padding: 5px;">CHA</th>
                        </tr>
                        <tr>
                            <td style="padding: 5px;">${statStr(monster.stats.str)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.dex)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.con)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.int)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.wis)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.cha)}</td>
                        </tr>
                    </table>
                </div>

                ${monster.savingThrows ? `<p><strong>Saving Throws:</strong> ${monster.savingThrows}</p>` : ''}
                ${monster.resistances ? `<p><strong>Damage Resistances:</strong> ${monster.resistances}</p>` : ''}
                ${monster.immunities ? `<p><strong>Immunities:</strong> ${monster.immunities}</p>` : ''}
                ${monster.proficiency ? `<p><strong>Proficiency:</strong> ${monster.proficiency}</p>` : ''}

                <p style="margin-top: 10px;"><strong>Traits:</strong> ${monster.traits.length} | <strong>Actions:</strong> ${monster.actions.length}</p>
            `;
            document.getElementById('monsterPreview').style.display = 'block';
        }

        function saveMonsterToDatabase() {
            if (!currentMonsterForStatblock) return;

            if (!currentMonsterForStatblock.name) {
                alert('Monstrum musí mít jméno!');
                return;
            }

            monsterDatabase.push({
                ...currentMonsterForStatblock,
                id: Date.now() + Math.random()
            });

            saveMonsterDatabaseToStorage();
            closeAddMonsterModal();
            renderMonsterList();
            alert(`${currentMonsterForStatblock.name} přidán do databáze!`);
        }

        // Render seznam monster v databázi
        function renderMonsterList() {
            const listDiv = document.getElementById('monsterList');

            if (monsterDatabase.length === 0) {
                listDiv.innerHTML = '<p style="color: #7f8c8d; text-align: center; padding: 40px;">Databáze je prázdná. Přidejte první monstrum!</p>';
                return;
            }

            listDiv.innerHTML = monsterDatabase.map(monster => `
                <div class="monster-card">
                    <div class="monster-info">
                        <div class="monster-name"
                             onmouseenter="showMonsterTooltip(event, ${monster.id})"
                             onmouseleave="hideMonsterTooltip()">
                            ${monster.name}
                        </div>
                        <div class="monster-stats-quick">
                            AC ${monster.ac} | HP ${monster.hp} | Init +${monster.initBonus} | ${monster.cr}
                        </div>
                    </div>
                    <div class="monster-actions" style="display: flex; gap: 5px; align-items: center; flex-wrap: wrap;">
                        <input type="number" id="count-${monster.id}" value="1" min="1" max="99" style="width: 50px;" title="Počet">
                        <input type="number" id="groupsize-${monster.id}" value="1" min="1" max="99" style="width: 50px;" title="Velikost skupiny">
                        <button onclick="addMonsterToCombat(${monster.id})" class="btn-success control-btn" title="Přidat do boje">➕</button>
                        <button onclick="openEditMonsterModal(${monster.id})" class="control-btn" style="background: #f39c12;" title="Editovat">✏️</button>
                        <button onclick="deleteMonsterFromDatabase(${monster.id})" class="btn-danger control-btn" title="Smazat">🗑️</button>
                    </div>
                </div>
            `).join('');
        }

        // Přidat monstrum z databáze do boje
        function addMonsterToCombat(monsterId) {
            const monster = monsterDatabase.find(m => m.id === monsterId);
            if (!monster) return;

            // Get count and group size from inputs
            const countInput = document.getElementById(`count-${monsterId}`);
            const groupSizeInput = document.getElementById(`groupsize-${monsterId}`);
            const count = parseInt(countInput?.value) || 1;
            const groupSize = parseInt(groupSizeInput?.value) || 1;

            // Calculate number of groups needed
            const numGroups = Math.ceil(count / groupSize);

            // Helper function to get group letter (A, B, C, ... Z, AA, AB, ...)
            const getGroupLetter = (index) => {
                let letter = '';
                let num = index;
                while (num >= 0) {
                    letter = String.fromCharCode(65 + (num % 26)) + letter;
                    num = Math.floor(num / 26) - 1;
                }
                return letter;
            };

            let addedCount = 0;
            const timestamp = Date.now();

            for (let groupIndex = 0; groupIndex < numGroups; groupIndex++) {
                const groupLetter = getGroupLetter(groupIndex);
                const groupId = `${monster.name.toLowerCase().replace(/\s/g, '_')}_${timestamp}_${groupLetter}`;
                const groupName = groupLetter;

                // Calculate how many monsters in this group
                const monstersInThisGroup = Math.min(groupSize, count - addedCount);

                for (let i = 0; i < monstersInThisGroup; i++) {
                    const monsterNumber = addedCount + 1;
                    const character = {
                        id: timestamp + Math.random() + addedCount,
                        name: `${monster.name} ${monsterNumber}`,
                        type: 'monster',
                        maxHp: monster.hp,
                        currentHp: monster.hp,
                        tempHp: 0,
                        ac: monster.ac,
                        initBonus: monster.initBonus,
                        initiative: null,
                        maxPower: monster.maxPower || 0,
                        currentPower: monster.maxPower || 0,
                        powerName: monster.powerName || 'Power',
                        effects: [],
                        monsterData: monster,
                        groupId: groupSize > 1 || numGroups > 1 ? groupId : null,
                        groupName: groupSize > 1 || numGroups > 1 ? groupName : null
                    };

                    characters.push(character);
                    addedCount++;
                }
            }

            renderCharacters();
            syncToServer();

            if (count === 1) {
                alert(`${monster.name} přidán do boje!`);
            } else {
                alert(`Přidáno ${count}x ${monster.name} ve ${numGroups} skupinách!`);
            }
        }

        // Smazat monstrum z databáze
        function deleteMonsterFromDatabase(monsterId) {
            const monster = monsterDatabase.find(m => m.id === monsterId);
            if (!monster) return;

            if (confirm(`Opravdu chcete smazat ${monster.name} z databáze?`)) {
                monsterDatabase = monsterDatabase.filter(m => m.id !== monsterId);
                saveMonsterDatabaseToStorage();
                renderMonsterList();
            }
        }

        // Editace monstra
        function openEditMonsterModal(monsterId) {
            const monster = monsterDatabase.find(m => m.id === monsterId);
            if (!monster) return;

            currentEditingMonsterId = monsterId;

            // Naplň formulář aktuálními hodnotami
            document.getElementById('editMonsterName').value = monster.name;
            document.getElementById('editMonsterAC').value = monster.ac;
            document.getElementById('editMonsterHP').value = monster.hp;
            document.getElementById('editMonsterSpeed').value = monster.speed || '30 ft.';
            document.getElementById('editMonsterType').value = monster.type || 'unknown';
            document.getElementById('editMonsterSize').value = monster.size || 'medium';
            document.getElementById('editMonsterPowerName').value = monster.powerName || 'Power';
            document.getElementById('editMonsterMaxPower').value = monster.maxPower || 0;

            document.getElementById('editMonsterModal').style.display = 'block';
        }

        function closeEditMonsterModal() {
            document.getElementById('editMonsterModal').style.display = 'none';
            currentEditingMonsterId = null;
        }

        function saveEditedMonster() {
            if (!currentEditingMonsterId) return;

            const monster = monsterDatabase.find(m => m.id === currentEditingMonsterId);
            if (!monster) return;

            // Aktualizuj hodnoty
            monster.name = document.getElementById('editMonsterName').value;
            monster.ac = parseInt(document.getElementById('editMonsterAC').value) || 10;
            monster.hp = parseInt(document.getElementById('editMonsterHP').value) || 10;
            monster.speed = document.getElementById('editMonsterSpeed').value || '30 ft.';
            monster.type = document.getElementById('editMonsterType').value || 'unknown';
            monster.size = document.getElementById('editMonsterSize').value || 'medium';
            monster.powerName = document.getElementById('editMonsterPowerName').value || 'Power';
            monster.maxPower = parseInt(document.getElementById('editMonsterMaxPower').value) || 0;

            // Ulož do localStorage a aktualizuj zobrazení
            saveMonsterDatabaseToStorage();
            renderMonsterList();
            closeEditMonsterModal();

            alert('Monstrum aktualizováno!');
        }

        // Tooltip systém
        let tooltipElement = null;

        // Pomocná funkce pro převod markdown na HTML
        function markdownToHtml(text) {
            // Převeď **bold** na <strong>
            let html = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

            // Zpracuj číslované seznamy
            const lines = html.split('\n');
            let inList = false;
            let result = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // Detekuj číslovaný seznam
                if (/^\d+\.\s+/.test(line)) {
                    if (!inList) {
                        result.push('<ol style="margin: 5px 0; padding-left: 20px;">');
                        inList = true;
                    }
                    result.push('<li>' + line.replace(/^\d+\.\s+/, '') + '</li>');
                } else {
                    if (inList) {
                        result.push('</ol>');
                        inList = false;
                    }
                    if (line) {
                        result.push(line + '<br>');
                    }
                }
            }

            if (inList) {
                result.push('</ol>');
            }

            return result.join('\n');
        }

        function showMonsterTooltip(event, monsterId) {
            const monster = monsterDatabase.find(m => m.id === monsterId);
            if (!monster) return;

            if (!tooltipElement) {
                tooltipElement = document.createElement('div');
                tooltipElement.className = 'tooltip';
                document.body.appendChild(tooltipElement);
            }

            // Formátuj staty s bonusy
            const statStr = (stat) => {
                const bonus = Math.floor((stat - 10) / 2);
                return `${stat} (${bonus >= 0 ? '+' : ''}${bonus})`;
            };

            const statsHtml = `
                <div class="tooltip-section" style="font-size: 0.85em;">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; text-align: center;">
                        <div><strong>STR</strong><br>${statStr(monster.stats.str)}</div>
                        <div><strong>DEX</strong><br>${statStr(monster.stats.dex)}</div>
                        <div><strong>CON</strong><br>${statStr(monster.stats.con)}</div>
                        <div><strong>INT</strong><br>${statStr(monster.stats.int)}</div>
                        <div><strong>WIS</strong><br>${statStr(monster.stats.wis)}</div>
                        <div><strong>CHA</strong><br>${statStr(monster.stats.cha)}</div>
                    </div>
                </div>
            `;

            const extraInfoHtml = `
                ${monster.savingThrows ? `<p style="font-size: 0.9em; margin: 3px 0;"><strong>Saves:</strong> ${monster.savingThrows}</p>` : ''}
                ${monster.immunities ? `<p style="font-size: 0.9em; margin: 3px 0;"><strong>Immunities:</strong> ${monster.immunities}</p>` : ''}
            `;

            const traitsHtml = monster.traits.length > 0
                ? `<div class="tooltip-section"><h4>Traits:</h4>${monster.traits.slice(0, 2).map(t => `<div style="margin-bottom: 10px;">${markdownToHtml(t)}</div>`).join('')}${monster.traits.length > 2 ? '<p><em>...a další</em></p>' : ''}</div>`
                : '';

            const actionsHtml = monster.actions.length > 0
                ? `<div class="tooltip-section"><h4>Actions:</h4>${monster.actions.slice(0, 2).map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}${monster.actions.length > 2 ? '<p><em>...a další</em></p>' : ''}</div>`
                : '';

            tooltipElement.innerHTML = `
                <h4>${monster.name}</h4>
                <div class="tooltip-section">
                    <p><strong>${monster.size} ${monster.type}</strong></p>
                    <p>AC ${monster.ac}, HP ${monster.hp}, Speed ${monster.speed}</p>
                    ${extraInfoHtml}
                </div>
                ${statsHtml}
                ${traitsHtml}
                ${actionsHtml}
            `;

            tooltipElement.classList.add('show');
            positionTooltip(event);
        }

        function hideMonsterTooltip() {
            if (tooltipElement) {
                tooltipElement.classList.remove('show');
            }
        }

        function positionTooltip(event) {
            if (!tooltipElement) return;

            const x = event.clientX + 10;
            const y = event.clientY + 10;

            tooltipElement.style.position = 'fixed';
            tooltipElement.style.left = x + 'px';
            tooltipElement.style.top = y + 'px';
        }

        // Export/Import databáze
        function exportMonsterDatabase() {
            const data = {
                monsters: monsterDatabase,
                timestamp: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dnd-monster-database-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importMonsterDatabase(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.monsters && Array.isArray(data.monsters)) {
                        monsterDatabase = data.monsters;
                        saveMonsterDatabaseToStorage();
                        renderMonsterList();
                        alert(`Úspěšně importováno ${data.monsters.length} monster!`);
                    } else {
                        alert('Neplatný formát databáze!');
                    }
                } catch (error) {
                    alert('Chyba při načítání databáze!');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Notion link import (placeholder)
        function importFromNotion() {
            const link = document.getElementById('notionLinkInput').value;
            if (!link.trim()) {
                alert('Vložte prosím Notion link!');
                return;
            }

            alert('Notion API import není zatím implementován. Prosím použijte copy/paste statblocku do textarea níže.');
            // TODO: Implementovat Notion API fetch
        }

        // Toggle statblock panel
        function toggleStatblock(charId) {
            const panel = document.getElementById(`statblock-${charId}`);
            if (panel) {
                panel.classList.toggle('show');
            }
        }

        // Předdefinované D&D 5e kondice/efekty
        const predefinedEffects = {
            // Debuffs
            'Blinded': { type: 'debuff', description: 'Postava nevidí a automaticky neuspěje u kontrol založených na zraku. Útoky proti postavě mají výhodu, útoky postavy mají nevýhodu.' },
            'Charmed': { type: 'debuff', description: 'Postava nemůže útočit na toho, kdo ji okouzlil. Ten má výhodu na sociální interakce.' },
            'Deafened': { type: 'debuff', description: 'Postava neslyší a automaticky neuspěje u kontrol založených na sluchu.' },
            'Frightened': { type: 'debuff', description: 'Postava má nevýhodu na ability checks a útoky, dokud je zdroj strachu ve výhledu. Nemůže se dobrovolně přiblížit ke zdroji.' },
            'Grappled': { type: 'debuff', description: 'Rychlost postavy je 0. Končí, když je grappler neschopný nebo postava unikne.' },
            'Incapacitated': { type: 'debuff', description: 'Postava nemůže provádět akce ani reakce.' },
            'Invisible': { type: 'buff', description: 'Postava je neviditelná. Útoky proti ní mají nevýhodu, její útoky mají výhodu.' },
            'Paralyzed': { type: 'debuff', description: 'Postava je neschopná a nemůže se hýbat ani mluvit. Automaticky neuspěje u Str a Dex záchran. Útoky proti ní mají výhodu.' },
            'Petrified': { type: 'debuff', description: 'Postava je zkamenělá, neschopná a neuvědomělá. Má odolnost proti všem typům poškození.' },
            'Poisoned': { type: 'debuff', description: 'Postava má nevýhodu na útoky a ability checks.' },
            'Prone': { type: 'debuff', description: 'Pohyb pouze plazením. Nevýhoda na útoky. Útoky zblízka mají výhodu, na dálku nevýhodu.' },
            'Restrained': { type: 'debuff', description: 'Rychlost 0, nevýhoda na útoky a Dex záchranné hody. Útoky proti postavě mají výhodu.' },
            'Stunned': { type: 'debuff', description: 'Postava je neschopná, nemůže se hýbat a mluví jen nejasně. Automaticky neuspěje u Str a Dex záchran.' },
            'Unconscious': { type: 'debuff', description: 'Postava je neschopná, nemůže se hýbat ani mluvit, neuvědomělá. Automaticky neuspěje u Str a Dex záchran.' },
            'Exhaustion': {
                type: 'debuff',
                hasLevels: true,
                maxLevel: 6,
                description: 'Vyčerpání - Level 1: Nevýhoda na ability checks. Level 2: Poloviční rychlost. Level 3: Nevýhoda na útoky a záchranné hody. Level 4: Max HP na polovinu. Level 5: Rychlost 0. Level 6: Smrt.'
            },

            // Buffs
            'Blessed': { type: 'buff', description: 'Bonus k záchranným hodům a útokům.' },
            'Hasted': { type: 'buff', description: 'Dvojnásobná rychlost, +2 AC, výhoda na Dex záchranné hody, extra akce.' },
            'Inspired': { type: 'buff', description: 'Bardic Inspiration - bonus k příštímu hodu.' },
            'Protected': { type: 'buff', description: 'Magická ochrana poskytující bonus k AC nebo záchranným hodům.' },
            'Enlarged': { type: 'buff', description: 'Zvětšená velikost, výhoda na Strength checks a záchranné hody, extra poškození.' },
            'Flying': { type: 'buff', description: 'Schopnost letu díky kouzlu nebo schopnosti.' },
            'Resistance': { type: 'buff', description: 'Odolnost proti určitému typu poškození.' },
            'Advantage': { type: 'buff', description: 'Výhoda na určitý typ hodů.' },

            // Neutrální/Situační
            'Concentrating': { type: 'neutral', description: 'Postava se soustředí na kouzlo. Při poškození hází záchranný hod na koncentraci.' },
            'Marked': { type: 'neutral', description: 'Postava je označená pro sledování nebo speciální efekt.' },
            'Raging': { type: 'buff', description: 'Barbarian Rage - bonus k poškození, odolnost proti fyzickému poškození.' },
            'Dodging': { type: 'buff', description: 'Postava se vyhýbá - útoky proti ní mají nevýhodu.' }
        };

        function addCharacter() {
            const name = document.getElementById('name').value.trim();
            const type = document.getElementById('type').value;
            const maxHp = parseInt(document.getElementById('maxHp').value);
            const currentHp = parseInt(document.getElementById('currentHp').value) || maxHp;
            const ac = parseInt(document.getElementById('ac').value) || 10;
            const initBonus = parseInt(document.getElementById('initBonus').value) || 0;
            const maxPower = parseInt(document.getElementById('maxPower').value) || 0;
            const currentPower = parseInt(document.getElementById('currentPower').value) || maxPower;

            if (!name || !maxHp) {
                alert('Vyplňte prosím jméno a maximální HP!');
                return;
            }

            const character = {
                id: Date.now() + Math.random(),
                name,
                type,
                maxHp,
                currentHp,
                tempHp: 0,
                ac,
                initBonus,
                initiative: null,
                maxPower,
                currentPower,
                effects: []
            };

            characters.push(character);

            // Vymazání formuláře
            document.getElementById('name').value = '';
            document.getElementById('maxHp').value = '';
            document.getElementById('currentHp').value = '';
            document.getElementById('ac').value = '';
            document.getElementById('initBonus').value = '';
            document.getElementById('maxPower').value = '';
            document.getElementById('currentPower').value = '';

            renderCharacters();
            syncToServer();
        }

        function duplicateMonster(id) {
            const original = characters.find(char => char.id === id);
            if (!original || original.type !== 'monster') return;

            // Najdi všechny monstra se stejným základním jménem
            const baseName = original.name.replace(/^\d+\.\s*/, ''); // Odstraň číslo z začátku
            const similarMonsters = characters.filter(char => 
                char.type === 'monster' && 
                (char.name === baseName || char.name.includes(baseName))
            );

            // Přečísluj všechna podobná monstra
            similarMonsters.forEach((monster, index) => {
                monster.name = `${index + 1}. ${baseName}`;
            });

            // Vytvoř kopii
            const newMonster = {
                ...original,
                id: Date.now() + Math.random(),
                name: `${similarMonsters.length + 1}. ${baseName}`,
                initiative: null,
                currentHp: original.maxHp,
                currentPower: original.maxPower,
                tempHp: 0,
                effects: [...original.effects]
            };

            characters.push(newMonster);
            renderCharacters();
        }

        function unlinkFromGroup(id) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character && character.groupId) {
                character.groupId = null;
                character.groupName = null;
                renderCharacters();
                syncToServer();
            }
        }

        function removeCharacter(id) {
            saveState();
            characters = characters.filter(char => char.id !== id);
            renderCharacters();
            syncToServer();
        }

        function updateHp(id, change) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (!character) return;

            if (change < 0) {
                let damage = -change;
                if (character.tempHp > 0) {
                    const tempDamage = Math.min(character.tempHp, damage);
                    character.tempHp -= tempDamage;
                    damage -= tempDamage;
                }
                if (damage > 0) {
                    character.currentHp = Math.max(0, character.currentHp - damage);
                }
            } else if (change > 0) {
                character.currentHp = Math.min(character.maxHp, character.currentHp + change);
            }
            renderCharacters();
            syncToServer();
        }

        function applyCustomDamage(id) {
            const input = document.querySelector(`[data-damage-id="${id}"]`);
            const damage = parseInt(input.value) || 0;
            if (damage > 0) {
                updateHp(id, -damage);
                input.value = '';
            }
        }

        function applyCustomHealing(id) {
            const input = document.querySelector(`[data-healing-id="${id}"]`);
            const healing = parseInt(input.value) || 0;
            if (healing > 0) {
                updateHp(id, healing);
                input.value = '';
            }
        }

        function setTempHp(id) {
            saveState();
            const input = document.querySelector(`[data-temp-id="${id}"]`);
            const tempHp = parseInt(input.value) || 0;
            const character = characters.find(char => char.id === id);
            if (character) {
                character.tempHp = Math.max(0, tempHp);
                input.value = '';
                renderCharacters();
            }
        }

        function applyMaxHpChange(id) {
            saveState();
            const input = document.querySelector(`[data-maxhp-id="${id}"]`);
            const change = parseInt(input.value) || 0;
            if (change === 0) return;
            const character = characters.find(char => char.id === id);
            if (!character) return;
            character.maxHp += change;
            if (character.currentHp > character.maxHp) {
                character.currentHp = character.maxHp;
            }
            const effectName = `Max HP ${change >= 0 ? '+' : ''}${change}`;
            character.effects.push(effectName);
            input.value = '';
            renderCharacters();
            if (currentEffectCharacterId === id) {
                renderEffects();
            }
        }

        function updatePower(id, change) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                character.currentPower = Math.max(0, character.currentPower + change);
                renderCharacters();
            }
        }

        function setPower(id, value) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                character.currentPower = Math.max(0, parseInt(value) || 0);
                renderCharacters();
            }
        }

        function setInitiative(id, value) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                const oldInitiative = character.initiative;
                character.initiative = parseInt(value) || null;

                // If character is in a group, update all group members
                if (character.groupId) {
                    characters.forEach(char => {
                        if (char.groupId === character.groupId && char.id !== id) {
                            char.initiative = character.initiative;
                        }
                    });
                }

                // Pokud probíhá boj, přeorganizuj pořadí
                if (combatState.active && character.initiative !== null) {
                    // Seřaď znovu podle iniciativy
                    const currentCharIndex = combatState.currentTurn;
                    const currentCharId = characters[currentCharIndex].id;
                    
                    characters.sort((a, b) => b.initiative - a.initiative);
                    
                    // Najdi novou pozici aktuální postavy
                    const newCurrentIndex = characters.findIndex(char => char.id === currentCharId);
                    
                    // Najdi novou pozici upravené postavy
                    const updatedCharIndex = characters.findIndex(char => char.id === id);
                    
                    // Pokud se upravená postava dostala před aktuální postavu, označit ji jako hranou
                    if (updatedCharIndex < newCurrentIndex && !combatState.playedThisRound.includes(updatedCharIndex)) {
                        combatState.playedThisRound.push(updatedCharIndex);
                    }
                    
                    // Aktualizuj současný tah
                    combatState.currentTurn = newCurrentIndex;
                    
                    // Přepočítej kdo už hrál v tomto kole
                    combatState.playedThisRound = combatState.playedThisRound
                        .map(oldIndex => {
                            // Najdi postavu podle původního indexu a vrať její nový index
                            const charAtOldIndex = characters.find((char, idx) => idx === oldIndex);
                            return charAtOldIndex ? characters.findIndex(c => c.id === charAtOldIndex.id) : -1;
                        })
                        .filter(idx => idx !== -1 && idx < newCurrentIndex);
                    
                    updateInitiativeDisplay();
                }
                
                renderCharacters();
            }
        }

        function rollInitiative(character) {
            const roll = Math.floor(Math.random() * 20) + 1;
            return roll + character.initBonus;
        }

        function startCombat() {
            // Hoď iniciativou pro všechny bez iniciativy
            const processedGroups = new Set();

            characters.forEach(char => {
                if (char.initiative === null) {
                    const initiative = rollInitiative(char);
                    char.initiative = initiative;

                    // If character is in a group, apply same initiative to all group members
                    if (char.groupId && !processedGroups.has(char.groupId)) {
                        processedGroups.add(char.groupId);
                        characters.forEach(c => {
                            if (c.groupId === char.groupId && c.id !== char.id) {
                                c.initiative = initiative;
                            }
                        });
                    }
                }
            });

            // Seřaď podle iniciativy
            characters.sort((a, b) => b.initiative - a.initiative);

            combatState.active = true;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('prevBtn').classList.remove('hidden');
            document.getElementById('nextBtn').classList.remove('hidden');
            document.getElementById('endBtn').classList.remove('hidden');
            document.getElementById('closeBtn').classList.remove('hidden');
            document.getElementById('saveCombatBtn').style.display = 'inline-block';

            updateInitiativeDisplay();
            renderCharacters();
            syncToServer();
        }

        function nextTurn() {
            saveState();
            if (combatState.currentTurn < characters.length - 1) {
                combatState.playedThisRound.push(combatState.currentTurn);
                combatState.currentTurn++;
            } else {
                // Nové kolo
                combatState.round++;
                combatState.currentTurn = 0;
                combatState.playedThisRound = [];
            }

            updateInitiativeDisplay();
            renderCharacters();
            syncToServer();
        }

        function previousTurn() {
            saveState();
            if (combatState.currentTurn > 0) {
                combatState.currentTurn--;
                // Odstraň z playedThisRound pokud tam byl
                combatState.playedThisRound = combatState.playedThisRound.filter(idx => idx !== combatState.currentTurn);
            } else {
                // Vrátit se na konec předchozího kola
                if (combatState.round > 1) {
                    combatState.round--;
                    combatState.currentTurn = characters.length - 1;
                    // V předchozím kole všichni hráli kromě posledního
                    combatState.playedThisRound = Array.from({length: characters.length - 1}, (_, i) => i);
                }
            }

            updateInitiativeDisplay();
            renderCharacters();
            syncToServer();
        }

        function endCombat() {
            combatState.active = false;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            // Reset pouze initiative, efekty ZŮSTÁVAJÍ, HP zůstává
            characters.forEach(char => {
                char.initiative = null;
                // Resetuj Moc pouze u monster
                if (char.type === 'monster') {
                    char.currentPower = char.maxPower;
                }
            });

            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('prevBtn').classList.add('hidden');
            document.getElementById('nextBtn').classList.add('hidden');
            document.getElementById('endBtn').classList.add('hidden');
            document.getElementById('closeBtn').classList.add('hidden');
            document.getElementById('saveCombatBtn').style.display = 'none';
            document.getElementById('initiativeOrder').classList.add('hidden');

            renderCharacters();
            syncToServer();
        }

        function closeCombat() {
            combatState.active = false;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            // Odstraň všechna monstra, u hráčů reset pouze iniciativy, efekty ZŮSTÁVAJÍ
            characters = characters.filter(char => {
                if (char.type === 'player') {
                    char.initiative = null;
                    // HP a efekty zůstávají
                    return true;
                }
                return false;
            });

            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('prevBtn').classList.add('hidden');
            document.getElementById('nextBtn').classList.add('hidden');
            document.getElementById('endBtn').classList.add('hidden');
            document.getElementById('closeBtn').classList.add('hidden');
            document.getElementById('saveCombatBtn').style.display = 'none';
            document.getElementById('initiativeOrder').classList.add('hidden');

            renderCharacters();
            syncToServer();
        }

        function openEffectModal(id) {
            currentEffectCharacterId = id;
            const character = characters.find(char => char.id === id);
            document.getElementById('effectCharacterName').textContent = character.name;
            renderEffects();
            document.getElementById('effectModal').style.display = 'block';
        }

        function closeEffectModal() {
            document.getElementById('effectModal').style.display = 'none';
            currentEffectCharacterId = null;
        }

        // Helper funkce pro práci s efekty
        function normalizeEffect(effect) {
            // Převede starý string formát nebo objekt na jednotný formát
            if (typeof effect === 'string') {
                return { name: effect, level: null };
            }
            return effect;
        }

        function effectToString(effect) {
            const normalized = normalizeEffect(effect);
            if (normalized.level !== null && normalized.level !== undefined) {
                return `${normalized.name} ${normalized.level}`;
            }
            return normalized.name;
        }

        function findEffectIndex(effects, effectName) {
            return effects.findIndex(e => {
                const norm = normalizeEffect(e);
                return norm.name === effectName;
            });
        }

        function addEffect() {
            saveState();
            const effectSelect = document.getElementById('effectSelect');
            const customInput = document.getElementById('newEffect');

            let effectName = '';
            if (effectSelect.value) {
                effectName = effectSelect.value;
                effectSelect.value = '';
            } else if (customInput.value.trim()) {
                effectName = customInput.value.trim();
                customInput.value = '';
            }

            if (!effectName || !currentEffectCharacterId) return;

            const character = characters.find(char => char.id === currentEffectCharacterId);

            // Zkontroluj jestli efekt už má
            const existingIndex = findEffectIndex(character.effects, effectName);
            if (existingIndex === -1) {
                // Přidej nový efekt
                const effectDef = predefinedEffects[effectName];
                if (effectDef && effectDef.hasLevels) {
                    character.effects.push({ name: effectName, level: 1 });
                } else {
                    character.effects.push({ name: effectName, level: null });
                }
                renderEffects();
                renderCharacters();
            }
        }

        function handleEffectRemoval(character, effectName) {
            const match = effectName.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                const amount = parseInt(match[1]);
                character.maxHp -= amount;
                if (character.currentHp > character.maxHp) {
                    character.currentHp = character.maxHp;
                }
            }
        }

        function changeEffectLevel(effectIndex, delta) {
            saveState();
            const character = characters.find(char => char.id === currentEffectCharacterId);
            if (!character) return;

            const effect = normalizeEffect(character.effects[effectIndex]);
            const effectDef = predefinedEffects[effect.name];

            if (effectDef && effectDef.hasLevels) {
                const newLevel = Math.max(1, Math.min(effectDef.maxLevel, (effect.level || 1) + delta));
                character.effects[effectIndex] = { name: effect.name, level: newLevel };
                renderEffects();
                renderCharacters();
            }
        }

        function removeEffect(effectIndex) {
            saveState();
            const character = characters.find(char => char.id === currentEffectCharacterId);
            const effect = normalizeEffect(character.effects[effectIndex]);
            handleEffectRemoval(character, effect.name);
            character.effects.splice(effectIndex, 1);
            renderEffects();
            renderCharacters();
        }

        function removeEffectFromCharacter(id, effectIndex) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (!character) return;
            const effect = normalizeEffect(character.effects[effectIndex]);
            const effectDef = predefinedEffects[effect.name];

            // Pokud efekt má levely a level > 1, sniž level místo odstranění
            if (effectDef && effectDef.hasLevels && effect.level && effect.level > 1) {
                character.effects[effectIndex] = { name: effect.name, level: effect.level - 1 };
            } else {
                // Level 1 nebo efekt bez levelů - odstranit
                handleEffectRemoval(character, effect.name);
                character.effects.splice(effectIndex, 1);
            }

            if (currentEffectCharacterId === id) {
                renderEffects();
            }
            renderCharacters();
        }

        function getEffectClass(effect) {
            const normalized = normalizeEffect(effect);
            if (predefinedEffects[normalized.name]) {
                return predefinedEffects[normalized.name].type;
            }
            const match = normalized.name.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                return parseInt(match[1]) >= 0 ? 'buff' : 'debuff';
            }
            return 'neutral'; // Vlastní efekty jsou neutrální
        }

        function getEffectDescription(effect) {
            const normalized = normalizeEffect(effect);
            if (predefinedEffects[normalized.name]) {
                return predefinedEffects[normalized.name].description;
            }
            const match = normalized.name.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                const amount = parseInt(match[1]);
                return `Maximální HP ${amount >= 0 ? 'zvýšeno' : 'sníženo'} o ${Math.abs(amount)}`;
            }
            return 'Vlastní efekt - bez popisu';
        }

        function renderEffects() {
            const character = characters.find(char => char.id === currentEffectCharacterId);
            const effectList = document.getElementById('effectList');

            if (character.effects.length === 0) {
                effectList.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">Žádné aktivní efekty</p>';
                return;
            }

            effectList.innerHTML = `
                <div class="effect-list-container">
                    ${character.effects.map((effect, index) => {
                        const normalized = normalizeEffect(effect);
                        const effectDef = predefinedEffects[normalized.name];
                        const hasLevels = effectDef && effectDef.hasLevels;
                        const displayText = effectToString(effect);

                        return `
                            <div class="effect-item">
                                <div style="flex: 1;">
                                    <span class="effect-tag ${getEffectClass(effect)}" title="${getEffectDescription(effect)}">${displayText}</span>
                                    <div class="effect-description">${getEffectDescription(effect)}</div>
                                    ${hasLevels ? `
                                        <div style="margin-top: 5px;">
                                            <button onclick="changeEffectLevel(${index}, -1)" class="btn-danger control-btn" style="font-size: 0.7em;">-</button>
                                            <span style="margin: 0 5px; font-weight: bold;">Level ${normalized.level || 1}</span>
                                            <button onclick="changeEffectLevel(${index}, 1)" class="btn-success control-btn" style="font-size: 0.7em;">+</button>
                                        </div>
                                    ` : ''}
                                </div>
                                <button onclick="removeEffect(${index})" class="btn-danger control-btn">✕</button>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function updateInitiativeDisplay() {
            const orderDiv = document.getElementById('initiativeOrder');
            if (combatState.active && characters.length > 0) {
                const currentChar = characters[combatState.currentTurn];
                orderDiv.innerHTML = `
                    <div class="turn-info">Kolo ${combatState.round} - Na tahu: ${currentChar.name} (Iniciativa: ${currentChar.initiative})</div>
                    <div>Pořadí iniciativy: ${characters.map((char, index) => 
                        `<span style="color: ${index === combatState.currentTurn ? '#f39c12' : 
                        combatState.playedThisRound.includes(index) ? '#7f8c8d' : '#2c3e50'}">${char.name} (${char.initiative})</span>`
                    ).join(' → ')}</div>
                `;
                orderDiv.classList.remove('hidden');
            } else {
                orderDiv.classList.add('hidden');
            }
        }

        // Helper pro Player mode - barevný indikátor zdraví monster
        function getMonsterHealthIndicator(currentHp, maxHp) {
            const percentage = (currentHp / maxHp) * 100;
            if (percentage > 66) return '🟢 Healthy';
            if (percentage > 33) return '🟡 Bloodied';
            return '🔴 Critical';
        }

        function getHpBarClass(currentHp, maxHp) {
            const percentage = (currentHp / maxHp) * 100;
            if (percentage <= 25) return 'low';
            if (percentage <= 50) return 'medium';
            return '';
        }

        // Generate consistent color for group based on groupId
        function getGroupColor(groupId) {
            if (!groupId) return '#95a5a6';

            // Predefined color palette for groups
            const colors = [
                '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#e67e22', '#16a085', '#d35400', '#8e44ad',
                '#c0392b', '#2980b9', '#27ae60', '#f1c40f', '#34495e'
            ];

            // Generate hash from groupId
            let hash = 0;
            for (let i = 0; i < groupId.length; i++) {
                hash = groupId.charCodeAt(i) + ((hash << 5) - hash);
            }

            // Use hash to select color
            const index = Math.abs(hash) % colors.length;
            return colors[index];
        }

        // LocalStorage funkce pro auto-save
        function saveToLocalStorage() {
            try {
                const data = {
                    characters: characters.map(char => ({
                        name: char.name,
                        type: char.type,
                        maxHp: char.maxHp,
                        currentHp: char.currentHp,
                        tempHp: char.tempHp,
                        ac: char.ac,
                        initBonus: char.initBonus,
                        maxPower: char.maxPower,
                        currentPower: char.currentPower,
                        powerName: char.powerName,
                        effects: char.effects,
                        initiative: char.initiative,
                        monsterData: char.monsterData,
                        groupId: char.groupId,
                        groupName: char.groupName
                    })),
                    combatState: combatState,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('dnd-tracker-data', JSON.stringify(data));
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('dnd-tracker-data');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (data.characters && Array.isArray(data.characters)) {
                        characters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || [],
                            initiative: char.initiative || null,
                            groupId: char.groupId || null,
                            groupName: char.groupName || null
                        }));

                        if (data.combatState) {
                            combatState = data.combatState;
                        }

                        renderCharacters();

                        // Obnovit UI tlačítka podle stavu boje
                        if (combatState.active) {
                            document.getElementById('startBtn').classList.add('hidden');
                            document.getElementById('prevBtn').classList.remove('hidden');
                            document.getElementById('nextBtn').classList.remove('hidden');
                            document.getElementById('endBtn').classList.remove('hidden');
                            document.getElementById('closeBtn').classList.remove('hidden');
                            document.getElementById('saveCombatBtn').style.display = 'inline-block';
                            updateInitiativeDisplay();
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // History/Undo systém
        function saveState() {
            const state = {
                characters: JSON.parse(JSON.stringify(characters)),
                combatState: JSON.parse(JSON.stringify(combatState))
            };
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }
        }

        function undo() {
            if (historyStack.length === 0) {
                alert('Nelze vrátit zpět - žádná historie změn!');
                return;
            }
            const previousState = historyStack.pop();
            characters = JSON.parse(JSON.stringify(previousState.characters));
            combatState = JSON.parse(JSON.stringify(previousState.combatState));

            // Obnovit UI podle stavu
            renderCharacters();
            if (combatState.active) {
                document.getElementById('startBtn').classList.add('hidden');
                document.getElementById('prevBtn').classList.remove('hidden');
                document.getElementById('nextBtn').classList.remove('hidden');
                document.getElementById('endBtn').classList.remove('hidden');
                document.getElementById('closeBtn').classList.remove('hidden');
                document.getElementById('saveCombatBtn').style.display = 'inline-block';
                updateInitiativeDisplay();
            } else {
                document.getElementById('startBtn').classList.remove('hidden');
                document.getElementById('prevBtn').classList.add('hidden');
                document.getElementById('nextBtn').classList.add('hidden');
                document.getElementById('endBtn').classList.add('hidden');
                document.getElementById('closeBtn').classList.add('hidden');
                document.getElementById('saveCombatBtn').style.display = 'none';
                document.getElementById('initiativeOrder').classList.add('hidden');
            }
        }

        // Drag and Drop funkce
        function handleDragStart(e, index) {
            if (!combatState.active) return;
            saveState();
            draggedCharacterIndex = index;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e, index) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            const card = e.currentTarget;
            card.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            if (!combatState.active) return;
            const card = e.currentTarget;
            card.classList.remove('drag-over');
        }

        function handleDrop(e, dropIndex) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            if (draggedCharacterIndex === dropIndex) return;

            // Uchování ID aktuální postavy na tahu
            const currentCharId = characters[combatState.currentTurn].id;

            // Přesuň postavu
            const draggedChar = characters[draggedCharacterIndex];
            characters.splice(draggedCharacterIndex, 1);
            characters.splice(dropIndex, 0, draggedChar);

            // Najdi novou pozici aktuální postavy na tahu
            const newCurrentIndex = characters.findIndex(char => char.id === currentCharId);
            combatState.currentTurn = newCurrentIndex;

            // Přepočítej playedThisRound indexy
            const newPlayedThisRound = [];
            for (let i = 0; i < newCurrentIndex; i++) {
                newPlayedThisRound.push(i);
            }
            combatState.playedThisRound = newPlayedThisRound;

            updateInitiativeDisplay();
            renderCharacters();
            draggedCharacterIndex = null;
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(card => {
                card.classList.remove('drag-over');
            });
            draggedCharacterIndex = null;
        }

        function renderCharacters() {
            const listDiv = document.getElementById('characterList');
            listDiv.innerHTML = characters.map((char, index) => {
                const isActive = combatState.active && index === combatState.currentTurn;
                const hasPlayed = combatState.active && combatState.playedThisRound.includes(index);
                const hpPercentage = (char.currentHp / char.maxHp) * 100;
                
                return `
                    <div class="character-card ${isActive ? 'active' : ''} ${hasPlayed ? 'played' : ''}"
                         draggable="${combatState.active ? 'true' : 'false'}"
                         data-index="${index}"
                         ondragstart="handleDragStart(event, ${index})"
                         ondragover="handleDragOver(event)"
                         ondragenter="handleDragEnter(event, ${index})"
                         ondragleave="handleDragLeave(event)"
                         ondrop="handleDrop(event, ${index})"
                         ondragend="handleDragEnd(event)"
                         style="${combatState.active ? 'cursor: move;' : ''}"
                    >
                        <div class="character-header">
                            <span class="character-name" onclick="openEffectModal(${char.id})">${char.name}</span>
                            <div>
                                <span class="character-type">${char.type === 'player' ? 'Hráč' : 'Monstrum'}</span>
                                ${char.groupName ? `<span class="group-badge" style="background: ${getGroupColor(char.groupId)}">Group ${char.groupName}</span>` : ''}
                            </div>
                            ${isDM ? `
                            <div>
                                ${char.groupName ? `<button onclick="unlinkFromGroup(${char.id})" class="control-btn" style="background: #95a5a6;" title="Oddělit od skupiny">🔗</button>` : ''}
                                ${char.type === 'monster' ? `<button onclick="duplicateMonster(${char.id})" class="btn-success control-btn">➕</button>` : ''}
                                <button onclick="removeCharacter(${char.id})" class="btn-danger control-btn">❌</button>
                            </div>
                            ` : ''}
                        </div>
                        
                        <div class="character-stats">
                            <div class="stat-group">
                                <div class="stat-label">HP</div>
                                <div class="stat-value">${
                                    (isPlayer && char.type === 'monster')
                                        ? getMonsterHealthIndicator(char.currentHp, char.maxHp)
                                        : `${char.currentHp}/${char.maxHp}`
                                }</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">Dočasné HP</div>
                                <div class="stat-value">${char.tempHp}</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">AC</div>
                                <div class="stat-value">${char.ac || 10}</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">Iniciativa</div>
                                <div class="stat-value">
                                    <input type="number" value="${char.initiative || ''}" onchange="setInitiative(${char.id}, this.value)" style="width: 60px; text-align: center;">
                                    <span class="init-bonus">(${char.initBonus >= 0 ? '+' : ''}${char.initBonus})</span>
                                </div>
                            </div>
                            ${(char.type === 'monster' && isDM) ? `
                            <div class="stat-group">
                                <div class="stat-label">${char.powerName || 'Power'}</div>
                                <div class="stat-value">${char.currentPower}/${char.maxPower}</div>
                            </div>
                            ` : ''}
                        </div>

                        ${(isDM || char.type === 'player') ? `
                        <div class="hp-bar">
                            <div class="hp-fill ${getHpBarClass(char.currentHp, char.maxHp)}" style="width: ${hpPercentage}%"></div>
                        </div>
                        ` : ''}

                        <div class="effects">
                            ${char.effects.map((effect, idx) => `<span class="effect-tag ${getEffectClass(effect)}" title="${getEffectDescription(effect)}" onclick="removeEffectFromCharacter(${char.id}, ${idx})">${effectToString(effect)}</span>`).join('')}
                        </div>

                        ${(char.monsterData && isDM) ? `
                        <div>
                            <span class="statblock-toggle" onclick="toggleStatblock(${char.id})">📖 Zobrazit statblock</span>
                            <div id="statblock-${char.id}" class="statblock-panel">
                                <div style="margin-bottom: 15px; font-size: 0.9em;">
                                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; text-align: center; background: #ecf0f1; padding: 10px; border-radius: 5px;">
                                        <div><strong>STR</strong><br>${char.monsterData.stats.str} (${Math.floor((char.monsterData.stats.str - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.str - 10) / 2)})</div>
                                        <div><strong>DEX</strong><br>${char.monsterData.stats.dex} (${Math.floor((char.monsterData.stats.dex - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.dex - 10) / 2)})</div>
                                        <div><strong>CON</strong><br>${char.monsterData.stats.con} (${Math.floor((char.monsterData.stats.con - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.con - 10) / 2)})</div>
                                        <div><strong>INT</strong><br>${char.monsterData.stats.int} (${Math.floor((char.monsterData.stats.int - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.int - 10) / 2)})</div>
                                        <div><strong>WIS</strong><br>${char.monsterData.stats.wis} (${Math.floor((char.monsterData.stats.wis - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.wis - 10) / 2)})</div>
                                        <div><strong>CHA</strong><br>${char.monsterData.stats.cha} (${Math.floor((char.monsterData.stats.cha - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.cha - 10) / 2)})</div>
                                    </div>
                                    ${char.monsterData.savingThrows ? `<p style="margin-top: 8px;"><strong>Saving Throws:</strong> ${char.monsterData.savingThrows}</p>` : ''}
                                    ${char.monsterData.resistances ? `<p style="margin-top: 5px;"><strong>Resistances:</strong> ${char.monsterData.resistances}</p>` : ''}
                                    ${char.monsterData.immunities ? `<p style="margin-top: 5px;"><strong>Immunities:</strong> ${char.monsterData.immunities}</p>` : ''}
                                </div>
                                <h5>Traits:</h5>
                                ${char.monsterData.traits.map(t => `<div style="margin-bottom: 10px;">${markdownToHtml(t)}</div>`).join('')}
                                <h5>Actions:</h5>
                                ${char.monsterData.actions.map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}
                            </div>
                        </div>
                        ` : ''}

                        ${(isDM || char.type === 'player') ? `
                        <div class="controls">
                            <button onclick="updateHp(${char.id}, -1)" class="btn-danger control-btn">HP -1</button>
                            <button onclick="updateHp(${char.id}, -10)" class="btn-danger control-btn">HP -10</button>
                            <button onclick="updateHp(${char.id}, 1)" class="btn-success control-btn">HP +1</button>
                            <button onclick="updateHp(${char.id}, 10)" class="btn-success control-btn">HP +10</button>
                        </div>

                        <div class="custom-hp-controls">
                            <input type="number" data-damage-id="${char.id}" class="custom-input" placeholder="Poškození">
                            <button onclick="applyCustomDamage(${char.id})" class="btn-danger control-btn">Aplikovat</button>
                            <input type="number" data-healing-id="${char.id}" class="custom-input" placeholder="Léčení">
                            <button onclick="applyCustomHealing(${char.id})" class="btn-success control-btn">Aplikovat</button>
                            <input type="number" data-temp-id="${char.id}" class="custom-input" placeholder="Dočasné HP">
                            <button onclick="setTempHp(${char.id})" class="btn-warning control-btn">Nastavit</button>
                            <input type="number" data-maxhp-id="${char.id}" class="custom-input" placeholder="Změna max HP">
                            <button onclick="applyMaxHpChange(${char.id})" class="btn-purple control-btn">Aplikovat</button>
                        </div>
                        ` : ''}

                        ${(char.type === 'monster' && isDM) ? `
                        <div class="power-controls">
                            <button onclick="updatePower(${char.id}, -1)" class="btn-danger control-btn">${char.powerName || 'Power'} -1</button>
                            <input type="number" value="${char.currentPower}" onchange="setPower(${char.id}, this.value)" class="power-input">
                            <button onclick="updatePower(${char.id}, 1)" class="btn-success control-btn">${char.powerName || 'Power'} +1</button>
                        </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            saveToLocalStorage();
        }

        function saveData() {
            const data = {
                characters: characters.map(char => ({
                    name: char.name,
                    type: char.type,
                    maxHp: char.maxHp,
                    currentHp: char.currentHp,
                    tempHp: char.tempHp,
                    ac: char.ac,
                    initBonus: char.initBonus,
                    maxPower: char.maxPower,
                    currentPower: char.currentPower,
                    effects: char.effects,
                    groupId: char.groupId,
                    groupName: char.groupName
                })),
                timestamp: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dnd-tracker-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function saveCombatState() {
            const data = {
                characters: characters.map(char => ({
                    name: char.name,
                    type: char.type,
                    maxHp: char.maxHp,
                    currentHp: char.currentHp,
                    tempHp: char.tempHp,
                    ac: char.ac,
                    initBonus: char.initBonus,
                    initiative: char.initiative,
                    maxPower: char.maxPower,
                    currentPower: char.currentPower,
                    powerName: char.powerName,
                    effects: char.effects,
                    monsterData: char.monsterData,
                    groupId: char.groupId,
                    groupName: char.groupName
                })),
                combatState: {
                    active: combatState.active,
                    currentTurn: combatState.currentTurn,
                    round: combatState.round,
                    playedThisRound: combatState.playedThisRound
                },
                timestamp: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dnd-combat-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.characters && Array.isArray(data.characters)) {
                        // Kumulativní načítání - přidej nové postavy k existujícím
                        const newCharacters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            initiative: null,
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || [],
                            groupId: char.groupId || null,
                            groupName: char.groupName || null
                        }));

                        characters = characters.concat(newCharacters);
                        renderCharacters();
                        alert(`Úspěšně načteno ${newCharacters.length} postav!`);
                    } else {
                        alert('Neplatný formát souboru!');
                    }
                } catch (error) {
                    alert('Chyba při načítání souboru!');
                }
            };
            reader.readAsText(file);
        }

        function loadCombatState(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.characters && Array.isArray(data.characters) && data.combatState) {
                        // Přepsat VŠE - kompletní načtení stavu boje
                        characters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || [],
                            initiative: char.initiative || null,
                            groupId: char.groupId || null,
                            groupName: char.groupName || null
                        }));

                        // Obnovit stav boje
                        combatState = data.combatState;

                        // Vyčistit historii (nový začátek)
                        historyStack = [];

                        renderCharacters();

                        // Obnovit UI podle stavu boje
                        if (combatState.active) {
                            document.getElementById('startBtn').classList.add('hidden');
                            document.getElementById('prevBtn').classList.remove('hidden');
                            document.getElementById('nextBtn').classList.remove('hidden');
                            document.getElementById('endBtn').classList.remove('hidden');
                            document.getElementById('closeBtn').classList.remove('hidden');
                            document.getElementById('saveCombatBtn').style.display = 'inline-block';
                            updateInitiativeDisplay();
                            alert(`Stav boje načten! Kolo ${combatState.round}, na tahu: ${characters[combatState.currentTurn]?.name}`);
                        } else {
                            document.getElementById('startBtn').classList.remove('hidden');
                            document.getElementById('prevBtn').classList.add('hidden');
                            document.getElementById('nextBtn').classList.add('hidden');
                            document.getElementById('endBtn').classList.add('hidden');
                            document.getElementById('closeBtn').classList.add('hidden');
                            document.getElementById('saveCombatBtn').style.display = 'none';
                            document.getElementById('initiativeOrder').classList.add('hidden');
                            alert(`Načteno ${characters.length} postav!`);
                        }
                    } else {
                        alert('Neplatný formát souboru stavu boje!');
                    }
                } catch (error) {
                    console.error('Error loading combat state:', error);
                    alert('Chyba při načítání stavu boje!');
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function clearAll() {
            if (confirm('Opravdu chcete vymazat všechna data?')) {
                characters = [];
                endCombat();
                renderCharacters();
            }
        }

        // Zavření modalu při kliknutí mimo něj
        window.onclick = function(event) {
            const modal = document.getElementById('effectModal');
            if (event.target === modal) {
                closeEffectModal();
            }
        }

        // Uložení před zavřením stránky
        window.addEventListener('beforeunload', function(e) {
            saveToLocalStorage();
        });

        // Klávesové zkratky
        document.addEventListener('keydown', function(e) {
            // Ignoruj zkratky pokud je otevřený modal nebo pokud píšeme do inputu
            if (document.getElementById('effectModal').style.display === 'block' ||
                e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key) {
                case ' ': // Space
                case 'PageUp':
                    if (combatState.active) {
                        e.preventDefault();
                        nextTurn();
                    }
                    break;
                case 'PageDown':
                    if (combatState.active) {
                        e.preventDefault();
                        previousTurn();
                    }
                    break;
                case 'Backspace':
                    e.preventDefault();
                    undo();
                    break;
            }
        });

        // ===== PLAYER MODE UI SETUP =====
        function setupPlayerMode() {
            // Update mode indicator
            document.getElementById('viewMode').textContent = isPlayer ? '👥 Player View' : '🎲 DM View';

            if (isPlayer) {
                // Hide DM-only sections
                const sectionsToHide = [
                    'dataManagementSection',
                    'addCharacterSection',
                    'monsterDatabaseSection'
                ];

                sectionsToHide.forEach(id => {
                    const section = document.getElementById(id);
                    if (section) section.style.display = 'none';
                });

                // Disable auto-save for players (server is source of truth)
                if (autoSaveInterval) {
                    clearInterval(autoSaveInterval);
                }
            }
        }

        // Inicializace
        if (isDM) {
            loadFromLocalStorage();
            loadMonsterDatabaseFromStorage();
            // Auto-save každých 30 sekund (DM only)
            autoSaveInterval = setInterval(saveToLocalStorage, 30000);
        }

        if (characters.length === 0) {
            renderCharacters();
        }

        // Initialize WebSocket
        initializeWebSocket();

        // Setup UI based on mode
        setupPlayerMode();
    </script>
</body>
</html>