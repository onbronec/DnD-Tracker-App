<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DnD Combat Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .form-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, button {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: bold;
        }

        button:hover {
            background: #2980b9;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-warning {
            background: #f39c12;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-purple {
            background: #9b59b6;
        }

        .btn-purple:hover {
            background: #8e44ad;
        }

        .character-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 15px;
        }

        .character-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 2px solid #ecf0f1;
        }

        .character-card.active {
            border-color: #f39c12;
            background: #fff8e1;
        }

        .character-card.played {
            opacity: 0.6;
            background: #f5f5f5;
        }

        .character-card.dragging {
            opacity: 0.5;
            cursor: move;
        }

        .character-card.drag-over {
            border-top: 3px solid #3498db;
        }

        .character-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .character-name {
            font-weight: bold;
            font-size: 1.1em;
            color: #2c3e50;
            cursor: pointer;
        }

        .character-name:hover {
            color: #3498db;
        }

        .character-type {
            background: #ecf0f1;
            padding: 3px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            color: #7f8c8d;
        }

        .character-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .stat-group {
            text-align: center;
            flex: 1;
        }

        .stat-label {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.2em;
            color: #2c3e50;
        }

        .init-bonus {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-left: 5px;
        }

        .controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }

        .control-btn {
            padding: 5px 10px;
            font-size: 0.8em;
        }

        .file-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .hidden {
            display: none;
        }

        .combat-controls {
            text-align: center;
            margin: 20px 0;
        }

        .initiative-order {
            font-size: 1.1em;
            margin-bottom: 20px;
            padding: 15px;
            background: #e8f4fd;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }

        .turn-info {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        #fileInput {
            display: none;
        }

        .hp-bar {
            width: 100%;
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .hp-fill {
            height: 100%;
            background: #27ae60;
            transition: width 0.3s, background-color 0.3s;
        }

        .hp-fill.low {
            background: #e74c3c;
        }

        .hp-fill.medium {
            background: #f39c12;
        }

        .effects {
            margin: 10px 0;
            min-height: 25px;
        }

        .effect-tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            margin: 2px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .effect-tag.buff {
            background: #27ae60;
            color: white;
        }

        .effect-tag.debuff {
            background: #e74c3c;
            color: white;
        }

        .effect-tag.neutral {
            background: #3498db;
            color: white;
        }

        .effect-tag:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .effect-controls {
            margin: 15px 0;
        }

        .effect-select {
            width: 150px;
            font-size: 0.9em;
            padding: 5px;
            margin-right: 10px;
        }

        .effect-input {
            width: 120px;
            font-size: 0.8em;
            padding: 5px;
            margin-right: 10px;
        }

        .effect-description {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.85em;
            line-height: 1.4;
            border-left: 3px solid #3498db;
        }

        .effect-list-container {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }

        .effect-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
            background: white;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .effect-item:hover {
            background: #f8f9fa;
        }

        .custom-hp-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            margin-top: 5px;
        }

        .custom-input {
            width: 60px;
            font-size: 0.8em;
            padding: 3px 6px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .power-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            margin-top: 5px;
        }

        .power-input {
            width: 40px;
            font-size: 0.8em;
            padding: 3px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêâ DnD Combat Tracker</h1>

        <div class="section">
            <h2>üìÅ Spr√°va dat</h2>
            <div class="file-controls">
                <button onclick="saveData()">üíæ Ulo≈æit data</button>
                <button onclick="document.getElementById('fileInput').click()">üìÇ Naƒç√≠st data (kumulativnƒõ)</button>
                <input type="file" id="fileInput" accept=".json" onchange="loadData(event)">
                <button onclick="clearAll()" class="btn-danger">üóëÔ∏è Vymazat v≈°e</button>
            </div>
        </div>

        <div class="section">
            <h2>‚ûï P≈ôidat postavu/monstrum</h2>
            <div class="form-group">
                <input type="text" id="name" placeholder="Jm√©no" required>
                <select id="type">
                    <option value="player">Hr√°ƒç</option>
                    <option value="monster">Monstrum</option>
                </select>
                <input type="number" id="maxHp" placeholder="Max HP" required>
                <input type="number" id="currentHp" placeholder="Aktu√°ln√≠ HP">
                <input type="number" id="ac" placeholder="AC (Armor Class)">
                <input type="number" id="initBonus" placeholder="Bonus na iniciativu">
                <input type="number" id="maxPower" placeholder="Max Moc">
                <input type="number" id="currentPower" placeholder="Aktu√°ln√≠ Moc">
                <button onclick="addCharacter()">P≈ôidat</button>
            </div>
        </div>

        <div class="section">
            <h2>‚öîÔ∏è Boj</h2>
            <div class="combat-controls">
                <button onclick="startCombat()" class="btn-success" id="startBtn">üé≤ Zah√°jit boj</button>
                <button onclick="previousTurn()" class="btn-warning hidden" id="prevBtn">‚¨ÖÔ∏è P≈ôedchoz√≠ tah</button>
                <button onclick="nextTurn()" class="btn-warning hidden" id="nextBtn">‚û°Ô∏è Dal≈°√≠ tah</button>
                <button onclick="endCombat()" class="btn-danger hidden" id="endBtn">üèÅ Ukonƒçit boj</button>
                <button onclick="closeCombat()" class="btn-purple hidden" id="closeBtn">üîí Uzav≈ô√≠t boj</button>
            </div>
            <div id="initiativeOrder" class="initiative-order hidden"></div>
        </div>

        <div class="section">
            <h2>üë• Postavy a monstra</h2>
            <div id="characterList" class="character-list"></div>
        </div>
    </div>

    <!-- Modal pro efekty -->
    <div id="effectModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEffectModal()">&times;</span>
            <h3>üé≠ Efekty pro <span id="effectCharacterName"></span></h3>
            <div id="effectList"></div>
            <div class="effect-controls">
                <h4>P≈ôidat efekt:</h4>
                <div style="margin: 10px 0;">
                    <select id="effectSelect" class="effect-select">
                        <option value="">-- Vyberte efekt --</option>
                        <optgroup label="üî¥ Debuffs">
                            <option value="Blinded">Blinded (Oslepen√Ω)</option>
                            <option value="Charmed">Charmed (Okouzlen√Ω)</option>
                            <option value="Deafened">Deafened (Ohlu≈°en√Ω)</option>
                            <option value="Frightened">Frightened (Vystra≈°en√Ω)</option>
                            <option value="Grappled">Grappled (Uchv√°cen√Ω)</option>
                            <option value="Incapacitated">Incapacitated (Neschopn√Ω)</option>
                            <option value="Paralyzed">Paralyzed (Paralyzovan√Ω)</option>
                            <option value="Petrified">Petrified (Zkamenƒõl√Ω)</option>
                            <option value="Poisoned">Poisoned (Otr√°ven√Ω)</option>
                            <option value="Prone">Prone (Le≈æ√≠c√≠)</option>
                            <option value="Restrained">Restrained (Spoutan√Ω)</option>
                            <option value="Stunned">Stunned (Omr√°ƒçen√Ω)</option>
                            <option value="Unconscious">Unconscious (Bezvƒõdom√Ω)</option>
                        </optgroup>
                        <optgroup label="üü¢ Buffs">
                            <option value="Blessed">Blessed (Po≈æehnan√Ω)</option>
                            <option value="Hasted">Hasted (Zrychlen√Ω)</option>
                            <option value="Inspired">Inspired (Inspirovan√Ω)</option>
                            <option value="Protected">Protected (Chr√°nƒõn√Ω)</option>
                            <option value="Enlarged">Enlarged (Zvƒõt≈°en√Ω)</option>
                            <option value="Flying">Flying (L√©taj√≠c√≠)</option>
                            <option value="Invisible">Invisible (Neviditeln√Ω)</option>
                            <option value="Resistance">Resistance (Odolnost)</option>
                            <option value="Advantage">Advantage (V√Ωhoda)</option>
                            <option value="Raging">Raging (Bƒõsn√≠c√≠)</option>
                            <option value="Dodging">Dodging (Vyh√Ωbaj√≠c√≠ se)</option>
                        </optgroup>
                        <optgroup label="üîµ Neutr√°ln√≠">
                            <option value="Concentrating">Concentrating (Soust≈ôedƒõn√≠)</option>
                            <option value="Marked">Marked (Oznaƒçen√Ω)</option>
                        </optgroup>
                    </select>
                    <button onclick="addEffect()" class="btn-success">P≈ôidat vybran√Ω</button>
                </div>
                <div style="margin: 10px 0;">
                    <input type="text" id="newEffect" class="effect-input" placeholder="Vlastn√≠ efekt">
                    <button onclick="addEffect()" class="btn-success">P≈ôidat vlastn√≠</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let characters = [];
        let combatState = {
            active: false,
            currentTurn: 0,
            round: 1,
            playedThisRound: []
        };
        let currentEffectCharacterId = null;
        let autoSaveInterval = null;
        let historyStack = [];
        const MAX_HISTORY = 20;
        let draggedCharacterIndex = null;
        
        // P≈ôeddefinovan√© D&D 5e kondice/efekty
        const predefinedEffects = {
            // Debuffs
            'Blinded': { type: 'debuff', description: 'Postava nevid√≠ a automaticky neuspƒõje u kontrol zalo≈æen√Ωch na zraku. √ötoky proti postavƒõ maj√≠ v√Ωhodu, √∫toky postavy maj√≠ nev√Ωhodu.' },
            'Charmed': { type: 'debuff', description: 'Postava nem≈Ø≈æe √∫toƒçit na toho, kdo ji okouzlil. Ten m√° v√Ωhodu na soci√°ln√≠ interakce.' },
            'Deafened': { type: 'debuff', description: 'Postava nesly≈°√≠ a automaticky neuspƒõje u kontrol zalo≈æen√Ωch na sluchu.' },
            'Frightened': { type: 'debuff', description: 'Postava m√° nev√Ωhodu na ability checks a √∫toky, dokud je zdroj strachu ve v√Ωhledu. Nem≈Ø≈æe se dobrovolnƒõ p≈ôibl√≠≈æit ke zdroji.' },
            'Grappled': { type: 'debuff', description: 'Rychlost postavy je 0. Konƒç√≠, kdy≈æ je grappler neschopn√Ω nebo postava unikne.' },
            'Incapacitated': { type: 'debuff', description: 'Postava nem≈Ø≈æe prov√°dƒõt akce ani reakce.' },
            'Invisible': { type: 'buff', description: 'Postava je neviditeln√°. √ötoky proti n√≠ maj√≠ nev√Ωhodu, jej√≠ √∫toky maj√≠ v√Ωhodu.' },
            'Paralyzed': { type: 'debuff', description: 'Postava je neschopn√° a nem≈Ø≈æe se h√Ωbat ani mluvit. Automaticky neuspƒõje u Str a Dex z√°chran. √ötoky proti n√≠ maj√≠ v√Ωhodu.' },
            'Petrified': { type: 'debuff', description: 'Postava je zkamenƒõl√°, neschopn√° a neuvƒõdomƒõl√°. M√° odolnost proti v≈°em typ≈Øm po≈°kozen√≠.' },
            'Poisoned': { type: 'debuff', description: 'Postava m√° nev√Ωhodu na √∫toky a ability checks.' },
            'Prone': { type: 'debuff', description: 'Pohyb pouze plazen√≠m. Nev√Ωhoda na √∫toky. √ötoky zbl√≠zka maj√≠ v√Ωhodu, na d√°lku nev√Ωhodu.' },
            'Restrained': { type: 'debuff', description: 'Rychlost 0, nev√Ωhoda na √∫toky a Dex z√°chrann√© hody. √ötoky proti postavƒõ maj√≠ v√Ωhodu.' },
            'Stunned': { type: 'debuff', description: 'Postava je neschopn√°, nem≈Ø≈æe se h√Ωbat a mluv√≠ jen nejasnƒõ. Automaticky neuspƒõje u Str a Dex z√°chran.' },
            'Unconscious': { type: 'debuff', description: 'Postava je neschopn√°, nem≈Ø≈æe se h√Ωbat ani mluvit, neuvƒõdomƒõl√°. Automaticky neuspƒõje u Str a Dex z√°chran.' },
            
            // Buffs
            'Blessed': { type: 'buff', description: 'Bonus k z√°chrann√Ωm hod≈Øm a √∫tok≈Øm.' },
            'Hasted': { type: 'buff', description: 'Dvojn√°sobn√° rychlost, +2 AC, v√Ωhoda na Dex z√°chrann√© hody, extra akce.' },
            'Inspired': { type: 'buff', description: 'Bardic Inspiration - bonus k p≈ô√≠≈°t√≠mu hodu.' },
            'Protected': { type: 'buff', description: 'Magick√° ochrana poskytuj√≠c√≠ bonus k AC nebo z√°chrann√Ωm hod≈Øm.' },
            'Enlarged': { type: 'buff', description: 'Zvƒõt≈°en√° velikost, v√Ωhoda na Strength checks a z√°chrann√© hody, extra po≈°kozen√≠.' },
            'Flying': { type: 'buff', description: 'Schopnost letu d√≠ky kouzlu nebo schopnosti.' },
            'Resistance': { type: 'buff', description: 'Odolnost proti urƒçit√©mu typu po≈°kozen√≠.' },
            'Advantage': { type: 'buff', description: 'V√Ωhoda na urƒçit√Ω typ hod≈Ø.' },
            
            // Neutr√°ln√≠/Situaƒçn√≠
            'Concentrating': { type: 'neutral', description: 'Postava se soust≈ôed√≠ na kouzlo. P≈ôi po≈°kozen√≠ h√°z√≠ z√°chrann√Ω hod na koncentraci.' },
            'Marked': { type: 'neutral', description: 'Postava je oznaƒçen√° pro sledov√°n√≠ nebo speci√°ln√≠ efekt.' },
            'Raging': { type: 'buff', description: 'Barbarian Rage - bonus k po≈°kozen√≠, odolnost proti fyzick√©mu po≈°kozen√≠.' },
            'Dodging': { type: 'buff', description: 'Postava se vyh√Ωb√° - √∫toky proti n√≠ maj√≠ nev√Ωhodu.' }
        };

        function addCharacter() {
            const name = document.getElementById('name').value.trim();
            const type = document.getElementById('type').value;
            const maxHp = parseInt(document.getElementById('maxHp').value);
            const currentHp = parseInt(document.getElementById('currentHp').value) || maxHp;
            const ac = parseInt(document.getElementById('ac').value) || 10;
            const initBonus = parseInt(document.getElementById('initBonus').value) || 0;
            const maxPower = parseInt(document.getElementById('maxPower').value) || 0;
            const currentPower = parseInt(document.getElementById('currentPower').value) || maxPower;

            if (!name || !maxHp) {
                alert('Vypl≈àte pros√≠m jm√©no a maxim√°ln√≠ HP!');
                return;
            }

            const character = {
                id: Date.now() + Math.random(),
                name,
                type,
                maxHp,
                currentHp,
                tempHp: 0,
                ac,
                initBonus,
                initiative: null,
                maxPower,
                currentPower,
                effects: []
            };

            characters.push(character);

            // Vymaz√°n√≠ formul√°≈ôe
            document.getElementById('name').value = '';
            document.getElementById('maxHp').value = '';
            document.getElementById('currentHp').value = '';
            document.getElementById('ac').value = '';
            document.getElementById('initBonus').value = '';
            document.getElementById('maxPower').value = '';
            document.getElementById('currentPower').value = '';

            renderCharacters();
        }

        function duplicateMonster(id) {
            const original = characters.find(char => char.id === id);
            if (!original || original.type !== 'monster') return;

            // Najdi v≈°echny monstra se stejn√Ωm z√°kladn√≠m jm√©nem
            const baseName = original.name.replace(/^\d+\.\s*/, ''); // Odstra≈à ƒç√≠slo z zaƒç√°tku
            const similarMonsters = characters.filter(char => 
                char.type === 'monster' && 
                (char.name === baseName || char.name.includes(baseName))
            );

            // P≈ôeƒç√≠sluj v≈°echna podobn√° monstra
            similarMonsters.forEach((monster, index) => {
                monster.name = `${index + 1}. ${baseName}`;
            });

            // Vytvo≈ô kopii
            const newMonster = {
                ...original,
                id: Date.now() + Math.random(),
                name: `${similarMonsters.length + 1}. ${baseName}`,
                initiative: null,
                currentHp: original.maxHp,
                currentPower: original.maxPower,
                tempHp: 0,
                effects: [...original.effects]
            };

            characters.push(newMonster);
            renderCharacters();
        }

        function removeCharacter(id) {
            saveState();
            characters = characters.filter(char => char.id !== id);
            renderCharacters();
        }

        function updateHp(id, change) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (!character) return;

            if (change < 0) {
                let damage = -change;
                if (character.tempHp > 0) {
                    const tempDamage = Math.min(character.tempHp, damage);
                    character.tempHp -= tempDamage;
                    damage -= tempDamage;
                }
                if (damage > 0) {
                    character.currentHp = Math.max(0, character.currentHp - damage);
                }
            } else if (change > 0) {
                character.currentHp = Math.min(character.maxHp, character.currentHp + change);
            }
            renderCharacters();
        }

        function applyCustomDamage(id) {
            const input = document.querySelector(`[data-damage-id="${id}"]`);
            const damage = parseInt(input.value) || 0;
            if (damage > 0) {
                updateHp(id, -damage);
                input.value = '';
            }
        }

        function applyCustomHealing(id) {
            const input = document.querySelector(`[data-healing-id="${id}"]`);
            const healing = parseInt(input.value) || 0;
            if (healing > 0) {
                updateHp(id, healing);
                input.value = '';
            }
        }

        function setTempHp(id) {
            saveState();
            const input = document.querySelector(`[data-temp-id="${id}"]`);
            const tempHp = parseInt(input.value) || 0;
            const character = characters.find(char => char.id === id);
            if (character) {
                character.tempHp = Math.max(0, tempHp);
                input.value = '';
                renderCharacters();
            }
        }

        function applyMaxHpChange(id) {
            saveState();
            const input = document.querySelector(`[data-maxhp-id="${id}"]`);
            const change = parseInt(input.value) || 0;
            if (change === 0) return;
            const character = characters.find(char => char.id === id);
            if (!character) return;
            character.maxHp += change;
            if (character.currentHp > character.maxHp) {
                character.currentHp = character.maxHp;
            }
            const effectName = `Max HP ${change >= 0 ? '+' : ''}${change}`;
            character.effects.push(effectName);
            input.value = '';
            renderCharacters();
            if (currentEffectCharacterId === id) {
                renderEffects();
            }
        }

        function updatePower(id, change) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                character.currentPower = Math.max(0, character.currentPower + change);
                renderCharacters();
            }
        }

        function setPower(id, value) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                character.currentPower = Math.max(0, parseInt(value) || 0);
                renderCharacters();
            }
        }

        function setInitiative(id, value) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                const oldInitiative = character.initiative;
                character.initiative = parseInt(value) || null;
                
                // Pokud prob√≠h√° boj, p≈ôeorganizuj po≈ôad√≠
                if (combatState.active && character.initiative !== null) {
                    // Se≈ôaƒè znovu podle iniciativy
                    const currentCharIndex = combatState.currentTurn;
                    const currentCharId = characters[currentCharIndex].id;
                    
                    characters.sort((a, b) => b.initiative - a.initiative);
                    
                    // Najdi novou pozici aktu√°ln√≠ postavy
                    const newCurrentIndex = characters.findIndex(char => char.id === currentCharId);
                    
                    // Najdi novou pozici upraven√© postavy
                    const updatedCharIndex = characters.findIndex(char => char.id === id);
                    
                    // Pokud se upraven√° postava dostala p≈ôed aktu√°ln√≠ postavu, oznaƒçit ji jako hranou
                    if (updatedCharIndex < newCurrentIndex && !combatState.playedThisRound.includes(updatedCharIndex)) {
                        combatState.playedThisRound.push(updatedCharIndex);
                    }
                    
                    // Aktualizuj souƒçasn√Ω tah
                    combatState.currentTurn = newCurrentIndex;
                    
                    // P≈ôepoƒç√≠tej kdo u≈æ hr√°l v tomto kole
                    combatState.playedThisRound = combatState.playedThisRound
                        .map(oldIndex => {
                            // Najdi postavu podle p≈Øvodn√≠ho indexu a vra≈• jej√≠ nov√Ω index
                            const charAtOldIndex = characters.find((char, idx) => idx === oldIndex);
                            return charAtOldIndex ? characters.findIndex(c => c.id === charAtOldIndex.id) : -1;
                        })
                        .filter(idx => idx !== -1 && idx < newCurrentIndex);
                    
                    updateInitiativeDisplay();
                }
                
                renderCharacters();
            }
        }

        function rollInitiative(character) {
            const roll = Math.floor(Math.random() * 20) + 1;
            return roll + character.initBonus;
        }

        function startCombat() {
            // Hoƒè iniciativou pro v≈°echny bez iniciativy
            characters.forEach(char => {
                if (char.initiative === null) {
                    char.initiative = rollInitiative(char);
                }
            });

            // Se≈ôaƒè podle iniciativy
            characters.sort((a, b) => b.initiative - a.initiative);

            combatState.active = true;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('prevBtn').classList.remove('hidden');
            document.getElementById('nextBtn').classList.remove('hidden');
            document.getElementById('endBtn').classList.remove('hidden');
            document.getElementById('closeBtn').classList.remove('hidden');

            updateInitiativeDisplay();
            renderCharacters();
        }

        function nextTurn() {
            saveState();
            if (combatState.currentTurn < characters.length - 1) {
                combatState.playedThisRound.push(combatState.currentTurn);
                combatState.currentTurn++;
            } else {
                // Nov√© kolo
                combatState.round++;
                combatState.currentTurn = 0;
                combatState.playedThisRound = [];
            }

            updateInitiativeDisplay();
            renderCharacters();
        }

        function previousTurn() {
            saveState();
            if (combatState.currentTurn > 0) {
                combatState.currentTurn--;
                // Odstra≈à z playedThisRound pokud tam byl
                combatState.playedThisRound = combatState.playedThisRound.filter(idx => idx !== combatState.currentTurn);
            } else {
                // Vr√°tit se na konec p≈ôedchoz√≠ho kola
                if (combatState.round > 1) {
                    combatState.round--;
                    combatState.currentTurn = characters.length - 1;
                    // V p≈ôedchoz√≠m kole v≈°ichni hr√°li kromƒõ posledn√≠ho
                    combatState.playedThisRound = Array.from({length: characters.length - 1}, (_, i) => i);
                }
            }

            updateInitiativeDisplay();
            renderCharacters();
        }

        function endCombat() {
            combatState.active = false;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            // Reset pouze initiative a efekty, HP z≈Øst√°v√°
            characters.forEach(char => {
                char.initiative = null;
                char.effects.forEach(effect => handleEffectRemoval(char, effect));
                char.effects = [];
                // Resetuj Moc pouze u monster
                if (char.type === 'monster') {
                    char.currentPower = char.maxPower;
                }
            });

            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('prevBtn').classList.add('hidden');
            document.getElementById('nextBtn').classList.add('hidden');
            document.getElementById('endBtn').classList.add('hidden');
            document.getElementById('closeBtn').classList.add('hidden');
            document.getElementById('initiativeOrder').classList.add('hidden');

            renderCharacters();
        }

        function closeCombat() {
            combatState.active = false;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            // Odstra≈à v≈°echna monstra a reset pouze iniciativy a efekt≈Ø u hr√°ƒç≈Ø
            characters = characters.filter(char => {
                if (char.type === 'player') {
                    char.initiative = null;
                    char.effects.forEach(effect => handleEffectRemoval(char, effect));
                    char.effects = [];
                    // HP z≈Øst√°v√° jak je
                    return true;
                }
                return false;
            });

            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('prevBtn').classList.add('hidden');
            document.getElementById('nextBtn').classList.add('hidden');
            document.getElementById('endBtn').classList.add('hidden');
            document.getElementById('closeBtn').classList.add('hidden');
            document.getElementById('initiativeOrder').classList.add('hidden');

            renderCharacters();
        }

        function openEffectModal(id) {
            currentEffectCharacterId = id;
            const character = characters.find(char => char.id === id);
            document.getElementById('effectCharacterName').textContent = character.name;
            renderEffects();
            document.getElementById('effectModal').style.display = 'block';
        }

        function closeEffectModal() {
            document.getElementById('effectModal').style.display = 'none';
            currentEffectCharacterId = null;
        }

        function addEffect() {
            saveState();
            const effectSelect = document.getElementById('effectSelect');
            const customInput = document.getElementById('newEffect');

            let effectName = '';
            if (effectSelect.value) {
                effectName = effectSelect.value;
                effectSelect.value = '';
            } else if (customInput.value.trim()) {
                effectName = customInput.value.trim();
                customInput.value = '';
            }

            if (!effectName || !currentEffectCharacterId) return;

            const character = characters.find(char => char.id === currentEffectCharacterId);
            if (!character.effects.includes(effectName)) {
                character.effects.push(effectName);
                renderEffects();
                renderCharacters();
            }
        }

        function handleEffectRemoval(character, effectName) {
            const match = effectName.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                const amount = parseInt(match[1]);
                character.maxHp -= amount;
                if (character.currentHp > character.maxHp) {
                    character.currentHp = character.maxHp;
                }
            }
        }

        function removeEffect(effectName) {
            saveState();
            const character = characters.find(char => char.id === currentEffectCharacterId);
            handleEffectRemoval(character, effectName);
            character.effects = character.effects.filter(effect => effect !== effectName);
            renderEffects();
            renderCharacters();
        }

        function removeEffectFromCharacter(id, effectName) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (!character) return;
            handleEffectRemoval(character, effectName);
            character.effects = character.effects.filter(effect => effect !== effectName);
            if (currentEffectCharacterId === id) {
                renderEffects();
            }
            renderCharacters();
        }

        function getEffectClass(effectName) {
            if (predefinedEffects[effectName]) {
                return predefinedEffects[effectName].type;
            }
            const match = effectName.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                return parseInt(match[1]) >= 0 ? 'buff' : 'debuff';
            }
            return 'neutral'; // Vlastn√≠ efekty jsou neutr√°ln√≠
        }

        function getEffectDescription(effectName) {
            if (predefinedEffects[effectName]) {
                return predefinedEffects[effectName].description;
            }
            const match = effectName.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                const amount = parseInt(match[1]);
                return `Maxim√°ln√≠ HP ${amount >= 0 ? 'zv√Ω≈°eno' : 'sn√≠≈æeno'} o ${Math.abs(amount)}`;
            }
            return 'Vlastn√≠ efekt - bez popisu';
        }

        function renderEffects() {
            const character = characters.find(char => char.id === currentEffectCharacterId);
            const effectList = document.getElementById('effectList');
            
            if (character.effects.length === 0) {
                effectList.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">≈Ω√°dn√© aktivn√≠ efekty</p>';
                return;
            }
            
            effectList.innerHTML = `
                <div class="effect-list-container">
                    ${character.effects.map(effect => `
                        <div class="effect-item">
                            <div>
                                <span class="effect-tag ${getEffectClass(effect)}" title="${getEffectDescription(effect)}" onclick="removeEffectFromCharacter(currentEffectCharacterId, '${effect}')">${effect}</span>
                                <div class="effect-description">${getEffectDescription(effect)}</div>
                            </div>
                            <button onclick="removeEffect('${effect}')" class="btn-danger control-btn">‚úï</button>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function updateInitiativeDisplay() {
            const orderDiv = document.getElementById('initiativeOrder');
            if (combatState.active && characters.length > 0) {
                const currentChar = characters[combatState.currentTurn];
                orderDiv.innerHTML = `
                    <div class="turn-info">Kolo ${combatState.round} - Na tahu: ${currentChar.name} (Iniciativa: ${currentChar.initiative})</div>
                    <div>Po≈ôad√≠ iniciativy: ${characters.map((char, index) => 
                        `<span style="color: ${index === combatState.currentTurn ? '#f39c12' : 
                        combatState.playedThisRound.includes(index) ? '#7f8c8d' : '#2c3e50'}">${char.name} (${char.initiative})</span>`
                    ).join(' ‚Üí ')}</div>
                `;
                orderDiv.classList.remove('hidden');
            } else {
                orderDiv.classList.add('hidden');
            }
        }

        function getHpBarClass(currentHp, maxHp) {
            const percentage = (currentHp / maxHp) * 100;
            if (percentage <= 25) return 'low';
            if (percentage <= 50) return 'medium';
            return '';
        }

        // LocalStorage funkce pro auto-save
        function saveToLocalStorage() {
            try {
                const data = {
                    characters: characters.map(char => ({
                        name: char.name,
                        type: char.type,
                        maxHp: char.maxHp,
                        currentHp: char.currentHp,
                        tempHp: char.tempHp,
                        ac: char.ac,
                        initBonus: char.initBonus,
                        maxPower: char.maxPower,
                        currentPower: char.currentPower,
                        effects: char.effects,
                        initiative: char.initiative
                    })),
                    combatState: combatState,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('dnd-tracker-data', JSON.stringify(data));
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('dnd-tracker-data');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (data.characters && Array.isArray(data.characters)) {
                        characters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || [],
                            initiative: char.initiative || null
                        }));

                        if (data.combatState) {
                            combatState = data.combatState;
                        }

                        renderCharacters();

                        // Obnovit UI tlaƒç√≠tka podle stavu boje
                        if (combatState.active) {
                            document.getElementById('startBtn').classList.add('hidden');
                            document.getElementById('prevBtn').classList.remove('hidden');
                            document.getElementById('nextBtn').classList.remove('hidden');
                            document.getElementById('endBtn').classList.remove('hidden');
                            document.getElementById('closeBtn').classList.remove('hidden');
                            updateInitiativeDisplay();
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // History/Undo syst√©m
        function saveState() {
            const state = {
                characters: JSON.parse(JSON.stringify(characters)),
                combatState: JSON.parse(JSON.stringify(combatState))
            };
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }
        }

        function undo() {
            if (historyStack.length === 0) {
                alert('Nelze vr√°tit zpƒõt - ≈æ√°dn√° historie zmƒõn!');
                return;
            }
            const previousState = historyStack.pop();
            characters = JSON.parse(JSON.stringify(previousState.characters));
            combatState = JSON.parse(JSON.stringify(previousState.combatState));

            // Obnovit UI podle stavu
            renderCharacters();
            if (combatState.active) {
                document.getElementById('startBtn').classList.add('hidden');
                document.getElementById('prevBtn').classList.remove('hidden');
                document.getElementById('nextBtn').classList.remove('hidden');
                document.getElementById('endBtn').classList.remove('hidden');
                document.getElementById('closeBtn').classList.remove('hidden');
                updateInitiativeDisplay();
            } else {
                document.getElementById('startBtn').classList.remove('hidden');
                document.getElementById('prevBtn').classList.add('hidden');
                document.getElementById('nextBtn').classList.add('hidden');
                document.getElementById('endBtn').classList.add('hidden');
                document.getElementById('closeBtn').classList.add('hidden');
                document.getElementById('initiativeOrder').classList.add('hidden');
            }
        }

        // Drag and Drop funkce
        function handleDragStart(e, index) {
            if (!combatState.active) return;
            saveState();
            draggedCharacterIndex = index;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e, index) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            const card = e.currentTarget;
            card.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            if (!combatState.active) return;
            const card = e.currentTarget;
            card.classList.remove('drag-over');
        }

        function handleDrop(e, dropIndex) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            if (draggedCharacterIndex === dropIndex) return;

            // Uchov√°n√≠ ID aktu√°ln√≠ postavy na tahu
            const currentCharId = characters[combatState.currentTurn].id;

            // P≈ôesu≈à postavu
            const draggedChar = characters[draggedCharacterIndex];
            characters.splice(draggedCharacterIndex, 1);
            characters.splice(dropIndex, 0, draggedChar);

            // Najdi novou pozici aktu√°ln√≠ postavy na tahu
            const newCurrentIndex = characters.findIndex(char => char.id === currentCharId);
            combatState.currentTurn = newCurrentIndex;

            // P≈ôepoƒç√≠tej playedThisRound indexy
            const newPlayedThisRound = [];
            for (let i = 0; i < newCurrentIndex; i++) {
                newPlayedThisRound.push(i);
            }
            combatState.playedThisRound = newPlayedThisRound;

            updateInitiativeDisplay();
            renderCharacters();
            draggedCharacterIndex = null;
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(card => {
                card.classList.remove('drag-over');
            });
            draggedCharacterIndex = null;
        }

        function renderCharacters() {
            const listDiv = document.getElementById('characterList');
            listDiv.innerHTML = characters.map((char, index) => {
                const isActive = combatState.active && index === combatState.currentTurn;
                const hasPlayed = combatState.active && combatState.playedThisRound.includes(index);
                const hpPercentage = (char.currentHp / char.maxHp) * 100;
                
                return `
                    <div class="character-card ${isActive ? 'active' : ''} ${hasPlayed ? 'played' : ''}"
                         draggable="${combatState.active ? 'true' : 'false'}"
                         data-index="${index}"
                         ondragstart="handleDragStart(event, ${index})"
                         ondragover="handleDragOver(event)"
                         ondragenter="handleDragEnter(event, ${index})"
                         ondragleave="handleDragLeave(event)"
                         ondrop="handleDrop(event, ${index})"
                         ondragend="handleDragEnd(event)"
                         style="${combatState.active ? 'cursor: move;' : ''}"
                    >
                        <div class="character-header">
                            <span class="character-name" onclick="openEffectModal(${char.id})">${char.name}</span>
                            <span class="character-type">${char.type === 'player' ? 'Hr√°ƒç' : 'Monstrum'}</span>
                            <div>
                                ${char.type === 'monster' ? `<button onclick="duplicateMonster(${char.id})" class="btn-success control-btn">‚ûï</button>` : ''}
                                <button onclick="removeCharacter(${char.id})" class="btn-danger control-btn">‚ùå</button>
                            </div>
                        </div>
                        
                        <div class="character-stats">
                            <div class="stat-group">
                                <div class="stat-label">HP</div>
                                <div class="stat-value">${char.currentHp}/${char.maxHp}</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">Doƒçasn√© HP</div>
                                <div class="stat-value">${char.tempHp}</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">AC</div>
                                <div class="stat-value">${char.ac || 10}</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">Iniciativa</div>
                                <div class="stat-value">
                                    <input type="number" value="${char.initiative || ''}" onchange="setInitiative(${char.id}, this.value)" style="width: 60px; text-align: center;">
                                    <span class="init-bonus">(${char.initBonus >= 0 ? '+' : ''}${char.initBonus})</span>
                                </div>
                            </div>
                            ${char.type === 'monster' ? `
                            <div class="stat-group">
                                <div class="stat-label">Moc</div>
                                <div class="stat-value">${char.currentPower}/${char.maxPower}</div>
                            </div>
                            ` : ''}
                        </div>

                        <div class="hp-bar">
                            <div class="hp-fill ${getHpBarClass(char.currentHp, char.maxHp)}" style="width: ${hpPercentage}%"></div>
                        </div>

                        <div class="effects">
                            ${char.effects.map(effect => `<span class="effect-tag ${getEffectClass(effect)}" title="${getEffectDescription(effect)}" onclick="removeEffectFromCharacter(${char.id}, '${effect}')">${effect}</span>`).join('')}
                        </div>
                        
                        <div class="controls">
                            <button onclick="updateHp(${char.id}, -1)" class="btn-danger control-btn">HP -1</button>
                            <button onclick="updateHp(${char.id}, -10)" class="btn-danger control-btn">HP -10</button>
                            <button onclick="updateHp(${char.id}, 1)" class="btn-success control-btn">HP +1</button>
                            <button onclick="updateHp(${char.id}, 10)" class="btn-success control-btn">HP +10</button>
                        </div>
                        
                        <div class="custom-hp-controls">
                            <input type="number" data-damage-id="${char.id}" class="custom-input" placeholder="Po≈°kozen√≠">
                            <button onclick="applyCustomDamage(${char.id})" class="btn-danger control-btn">Aplikovat</button>
                            <input type="number" data-healing-id="${char.id}" class="custom-input" placeholder="L√©ƒçen√≠">
                            <button onclick="applyCustomHealing(${char.id})" class="btn-success control-btn">Aplikovat</button>
                            <input type="number" data-temp-id="${char.id}" class="custom-input" placeholder="Doƒçasn√© HP">
                            <button onclick="setTempHp(${char.id})" class="btn-warning control-btn">Nastavit</button>
                            <input type="number" data-maxhp-id="${char.id}" class="custom-input" placeholder="Zmƒõna max HP">
                            <button onclick="applyMaxHpChange(${char.id})" class="btn-purple control-btn">Aplikovat</button>
                        </div>

                        ${char.type === 'monster' ? `
                        <div class="power-controls">
                            <button onclick="updatePower(${char.id}, -1)" class="btn-danger control-btn">Moc -1</button>
                            <input type="number" value="${char.currentPower}" onchange="setPower(${char.id}, this.value)" class="power-input">
                            <button onclick="updatePower(${char.id}, 1)" class="btn-success control-btn">Moc +1</button>
                        </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            saveToLocalStorage();
        }

        function saveData() {
            const data = {
                characters: characters.map(char => ({
                    name: char.name,
                    type: char.type,
                    maxHp: char.maxHp,
                    currentHp: char.currentHp,
                    tempHp: char.tempHp,
                    ac: char.ac,
                    initBonus: char.initBonus,
                    maxPower: char.maxPower,
                    currentPower: char.currentPower,
                    effects: char.effects
                })),
                timestamp: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dnd-tracker-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.characters && Array.isArray(data.characters)) {
                        // Kumulativn√≠ naƒç√≠t√°n√≠ - p≈ôidej nov√© postavy k existuj√≠c√≠m
                        const newCharacters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            initiative: null,
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || []
                        }));

                        characters = characters.concat(newCharacters);
                        renderCharacters();
                        alert(`√öspƒõ≈°nƒõ naƒçteno ${newCharacters.length} postav!`);
                    } else {
                        alert('Neplatn√Ω form√°t souboru!');
                    }
                } catch (error) {
                    alert('Chyba p≈ôi naƒç√≠t√°n√≠ souboru!');
                }
            };
            reader.readAsText(file);
        }

        function clearAll() {
            if (confirm('Opravdu chcete vymazat v≈°echna data?')) {
                characters = [];
                endCombat();
                renderCharacters();
            }
        }

        // Zav≈ôen√≠ modalu p≈ôi kliknut√≠ mimo nƒõj
        window.onclick = function(event) {
            const modal = document.getElementById('effectModal');
            if (event.target === modal) {
                closeEffectModal();
            }
        }

        // Ulo≈æen√≠ p≈ôed zav≈ôen√≠m str√°nky
        window.addEventListener('beforeunload', function(e) {
            saveToLocalStorage();
        });

        // Kl√°vesov√© zkratky
        document.addEventListener('keydown', function(e) {
            // Ignoruj zkratky pokud je otev≈ôen√Ω modal nebo pokud p√≠≈°eme do inputu
            if (document.getElementById('effectModal').style.display === 'block' ||
                e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key) {
                case ' ': // Space
                case 'PageUp':
                    if (combatState.active) {
                        e.preventDefault();
                        nextTurn();
                    }
                    break;
                case 'PageDown':
                    if (combatState.active) {
                        e.preventDefault();
                        previousTurn();
                    }
                    break;
                case 'Backspace':
                    e.preventDefault();
                    undo();
                    break;
            }
        });

        // Inicializace
        loadFromLocalStorage();
        if (characters.length === 0) {
            renderCharacters();
        }

        // Auto-save ka≈æd√Ωch 30 sekund
        autoSaveInterval = setInterval(saveToLocalStorage, 30000);
    </script>
</body>
</html>